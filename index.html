<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    * {
      box-sizing: border-box;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    body {
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      background: #000;
      width: 100vw;
      height: 100vh;
    }
    /* Canvas –¥–ª—è –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω–æ–≥–æ —Ñ–æ–Ω–∞ */
    #planetBackgroundCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    /* –ú–æ–±–∏–ª—å–Ω–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è UI */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      text-align: center;
      z-index: 20;
      padding: 8px 50px 8px 0;
      backdrop-filter: blur(6px);
      border-bottom: 1px solid;
      background: rgba(0, 0, 0, 0.5);
    }
    #gameTitle { 
      margin: 0; 
      font-size: clamp(1.1em, 4vw, 1.4em); 
      color: white;
    }
    /* –û–ë–ù–û–í–õ–ï–ù–ù–û–ï –†–ê–°–ü–û–õ–û–ñ–ï–ù–ò–ï HUD - –°–õ–ï–í–ê –ü–û–î –ó–ê–ì–û–õ–û–í–ö–û–ú */
    #hud-left {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 3px;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 12px;
      border-radius: 8px;
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    .hud-item {
      font-size: clamp(0.7em, 3vw, 0.8em);
      display: flex;
      align-items: center;
      gap: 6px;
      color: white;
      white-space: nowrap;
    }
    .hud-item i {
      width: 20px;
      text-align: center;
    }
    .hud-item#coins { color: #FFD54F; text-shadow: 0 0 4px rgba(255,213,79,0.6); }
    .hud-item#clickPowerInfo { color: #4FC3F7; text-shadow: 0 0 4px rgba(79,195,247,0.6); }
    .hud-item#helperTimer { color: #69F0AE; text-shadow: 0 0 4px rgba(105,240,174,0.6); }
    .hud-item#critChanceInfo, .hud-item#critMultiplierInfo { color: #FFD700; text-shadow: 0 0 4px rgba(255,215,0,0.6); }

    /* –ü–†–û–ì–†–ï–°–°-–ë–ê–† –í –¶–ï–ù–¢–†–ï –ü–û–î –ù–ê–ó–í–ê–ù–ò–ï–ú –õ–û–ö–ê–¶–ò–ò */
    #progressContainer {
      position: absolute;
      top: 45px;
      left: 50%;
      transform: translateX(-50%);
      width: min(90%, 400px);
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      z-index: 25;
    }
    #progressText {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-size: clamp(0.6em, 2.5vw, 0.7em);
      color: #a0d2ff;
      text-shadow: 0 0 3px rgba(160,210,255,0.6);
      z-index: 25;
      text-align: center;
      width: min(90%, 400px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
    #saveBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 30;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      color: #4CAF50;
      transition: transform 0.1s;
    }
    #saveBtn:active { transform: scale(0.92); }
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ —É–ª—É—á—à–µ–Ω–∏–π */
    .upgrade-btn {
      position: absolute;
      right: 10px;
      width: clamp(48px, 12vw, 52px);
      height: clamp(48px, 12vw, 52px);
      border: none;
      border-radius: 8px;
      font-size: clamp(1.1em, 4vw, 1.3em);
      cursor: pointer;
      z-index: 30;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      padding: 3px;
      overflow: hidden;
    }
    .upgrade-btn:active { transform: scale(0.92); }
    #upgradeClickBtn { bottom: 75px; }
    #upgradeHelperBtn { bottom: 135px; }
    #upgradeCritChanceBtn { bottom: 195px; }
    #upgradeCritMultBtn { bottom: 255px; }
    #upgradeHelperDmgBtn { bottom: 315px; }
    .upgrade-cost {
      font-size: clamp(0.5em, 2.5vw, 0.55em);
      margin-top: 1px;
      font-weight: bold;
      text-shadow: 0 0 2px rgba(0,0,0,0.8);
    }

    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –±–ª–æ–∫–∏ */
    .moving-block {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      font-weight: bold;
      font-size: clamp(0.8em, 4vw, 0.9em);
      font-family: 'Orbitron', monospace;
      transition: transform 0.1s;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      overflow: hidden;
      min-width: 60px;
      min-height: 60px;
    }
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —ç–∫—Ä–∞–Ω—ã */
    #welcomeScreen, #gameOverScreen, #saveScreen, #developmentScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
      text-align: center;
      padding: 15px;
      box-sizing: border-box;
    }
    #welcomeScreen h2 {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-bottom: 15px;
    }
    #welcomeScreen p {
      max-width: 95%;
      text-align: center;
      margin: 8px 0;
      line-height: 1.4;
      font-size: clamp(0.9em, 3.5vw, 1em);
    }
    .btn {
      padding: clamp(10px, 3vw, 12px) clamp(25px, 6vw, 30px);
      margin-top: 15px;
      font-size: clamp(1em, 4vw, 1.1em);
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px; /* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –∫–∞—Å–∞–Ω–∏—è */
    }
    #continueBtn {
      background: #2196F3;
      margin-bottom: 10px;
    }
    #continueBtn.save-available {
      background: #4CAF50;
    }
    #continueBtn.no-save {
      background: #f44336;
    }
    #gameOverScreen h2 {
      font-size: clamp(1.6em, 6vw, 2.2em);
      margin-bottom: 15px;
    }
    #finalScore { font-size: clamp(1.1em, 4vw, 1.4em); margin-bottom: 15px; }
    #restartBtn, #shareBtn, #dailyRewardBtn {
      padding: clamp(8px, 2.5vw, 10px) clamp(20px, 5vw, 24px);
      margin: 6px;
      font-size: clamp(0.9em, 3.5vw, 1em);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px;
    }
    /* –≠–∫—Ä–∞–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
    #saveScreen {
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      display: none;
    }
    #saveScreen h2 {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-bottom: 20px;
    }
    #saveScreen p {
      max-width: 90%;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    /* –≠–∫—Ä–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ */
    #developmentScreen {
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(15px);
      display: none;
    }
    #developmentScreen h2 {
      font-size: clamp(1.5em, 6vw, 2.2em);
      margin-bottom: 20px;
      color: #ff9800;
    }
    #developmentScreen p {
      max-width: 90%;
      margin-bottom: 20px;
      line-height: 1.5;
      font-size: clamp(1em, 4vw, 1.2em);
    }
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã —É—Ä–æ–Ω–∞ - –û–ë–ù–û–í–õ–ï–ù–û: —É–ª—É—á—à–µ–Ω–∞ —á–∏—Ç–∞–µ–º–æ—Å—Ç—å */
    .damage-text {
      font-size: clamp(1em, 4vw, 1.1em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      opacity: 1;
      transition: transform 0.5s, opacity 0.5s;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      max-width: 100px;
      text-align: center;
      font-weight: bold;
      color: #FFFFFF;
      -webkit-text-stroke: 1px #000000;
    }
    .combo-text {
      font-size: clamp(1.4em, 5vw, 1.8em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: comboPop 0.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 150px;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      font-weight: bold;
      color: #FFD700;
      -webkit-text-stroke: 1px #000000;
    }
    .reward-text {
      font-size: clamp(1.1em, 4vw, 1.3em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: rewardFloat 1.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 120px;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      font-weight: bold;
      color: #FFFFFF;
      -webkit-text-stroke: 1px #000000;
    }
    /* –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è landscape —Ä–µ–∂–∏–º–∞ */
    @media (max-height: 500px) and (orientation: landscape) {
      #header {
        padding: 4px 40px 4px 0;
      }
      #hud-left {
        top: 40px;
        left: 8px;
        gap: 2px;
      }
      .upgrade-btn {
        width: 40px;
        height: 40px;
        right: 8px;
      }
      #upgradeClickBtn { bottom: 60px; }
      #upgradeHelperBtn { bottom: 110px; }
      #upgradeCritChanceBtn { bottom: 160px; }
      #upgradeCritMultBtn { bottom: 210px; }
      #upgradeHelperDmgBtn { bottom: 260px; }
      #progressContainer {
        top: 35px;
        height: 6px;
      }
      #progressText {
        top: 48px;
        font-size: 0.6em;
      }
    }
    /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ */
    #progressBar {
      height: 100%;
      background: linear-gradient(90deg, #bb86fc, #4a55e0);
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }
    #gameArea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 5;
    }
    .crack-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image: 
        radial-gradient(circle at 30% 30%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 70% 70%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 50% 20%, transparent 60%, rgba(0,0,0,0.3) 65%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .crack-1 { opacity: 0.3; }
    .crack-2 { opacity: 0.6; }
    .crack-3 { opacity: 0.9; }
    #levelAnnounce {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(1.2em, 5vw, 1.5em);
      font-weight: bold;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      color: white;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    .upgrade-btn.btn-available { 
      background: linear-gradient(135deg, #4CAF50, #388E3C); 
      color: white; 
    }
    .upgrade-btn.btn-unavailable { 
      background: linear-gradient(135deg, #666, #444); 
      color: #ccc; 
      cursor: not-allowed; 
      opacity: 0.7;
    }
    .tooltip {
      position: absolute;
      bottom: 70px;
      right: 15px;
      padding: 5px 8px;
      border-radius: 6px;
      font-size: clamp(0.75em, 3vw, 0.85em);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      z-index: 35;
    }
    #particlesCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 6;
    }
    @keyframes comboPop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes rewardFloat {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }
    .helper {
      position: absolute;
      width: 35px;
      height: 35px;
      background: radial-gradient(circle, #69f0ae, #00e676);
      border-radius: 50%;
      z-index: 12;
      pointer-events: none;
      box-shadow: 0 0 15px #69f0ae;
      animation: helperFloat 3s ease-in-out infinite;
    }
    @keyframes helperFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }
    .helper-beam {
      position: absolute;
      width: 3px;
      background: linear-gradient(to top, transparent, #69f0ae);
      z-index: 11;
      pointer-events: none;
      animation: beamPulse 0.5s ease-out;
    }
    @keyframes beamPulse {
      0% { height: 0; opacity: 1; }
      100% { height: 100px; opacity: 0; }
    }
    #welcomeScreen { 
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    }
    #gameOverScreen {
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
    }
    #restartBtn { background: #4CAF50; color: white; }
    #shareBtn { background: #00c853; color: white; }
    #dailyRewardBtn { background: #ffeb3b; color: #000; }
    /* –°—Ç–∏–ª–∏ –¥–ª—è —Ä–µ–¥–∫–∏—Ö –±–ª–æ–∫–æ–≤ */
    .block-gold {
        background: linear-gradient(135deg, #ffd700, #ff6b00) !important;
        animation: gold-shimmer 3s infinite;
    }
    .block-rainbow {
        background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #8b00ff) !important;
        background-size: 400% 400%;
        animation: rainbow 3s ease infinite;
    }
    .block-crystal {
        background: linear-gradient(45deg, #00ffff, #ffffff, #00ffff) !important;
        box-shadow: 0 0 25px #00ffff, 0 0 10px #ffffff inset !important;
        animation: crystalPulse 2s ease-in-out infinite !important;
    }
    .block-mystery {
        background: linear-gradient(45deg, #9b59b6, #e74c3c, #3498db) !important;
        background-size: 300% 300% !important;
        box-shadow: 0 0 20px rgba(155, 89, 182, 0.7) !important;
        animation: mysteryShift 4s ease-in-out infinite !important;
    }
    /* –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –°–¢–ò–õ–ò –î–õ–Ø –≠–§–§–ï–ö–¢–ê –í–ó–†–´–í–ê - –£–í–ï–õ–ò–ß–ï–ù–ù–ê–Ø –û–ë–õ–ê–°–¢–¨ */
    .explosion {
      position: absolute;
      pointer-events: none;
      z-index: 15;
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
      transform: translate(-50%, -50%);
      animation: explode 0.6s ease-out forwards;
    }
    @keyframes explode {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
      }
      50% {
        opacity: 0.8;
      }
      100% {
        transform: translate(-50%, -50%) scale(2.5);
        opacity: 0;
      }
    }
    .explosion-particle {
      position: absolute;
      pointer-events: none;
      z-index: 14;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: particleFly 0.8s ease-out forwards;
    }
    @keyframes particleFly {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }
    /* –ê–¥–∞–ø—Ç–∞—Ü–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ */
    @media (max-width: 768px) {
      .explosion {
        width: 150px;
        height: 150px;
      }
      .explosion-particle {
        width: 10px;
        height: 10px;
      }
    }
    @keyframes gold-shimmer {
        0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
        50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 107, 0, 0.6) inset; }
        100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
    }
    @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    @keyframes crystalPulse {
        0%, 100% { transform: translateX(-50%) scale(1); }
        50% { transform: translateX(-50%) scale(1.05); }
    }
    @keyframes mysteryShift {
        0%, 100% { background-position: 0% 50%; filter: hue-rotate(0deg); }
        50% { background-position: 100% 50%; filter: hue-rotate(180deg); }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Canvas –¥–ª—è –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω–æ–≥–æ —Ñ–æ–Ω–∞ -->
  <canvas id="planetBackgroundCanvas"></canvas>
  <!-- UI -->
  <div id="header">
    <h2 id="gameTitle">‚òø –ú–µ—Ä–∫—É—Ä–∏–π</h2>
  </div>
  <!-- –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è -->
  <button id="saveBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–≥—Ä—É">
    <i class="fas fa-save"></i>
  </button>
  <!-- –û–ë–ù–û–í–õ–ï–ù–ù–´–ô HUD - –°–õ–ï–í–ê, –° –ò–ö–û–ù–ö–ê–ú–ò –ö–ê–ö –í –£–õ–£–ß–®–ï–ù–ò–Ø–• -->
  <div id="hud-left">
    <div class="hud-item" id="coins"><i class="fas fa-gem"></i> –ö—Ä–∏—Å—Ç–∞–ª–ª—ã: <span id="coins-value">0</span></div>
    <div class="hud-item" id="clickPowerInfo"><i class="fas fa-fist-raised"></i> –°–∏–ª–∞: <span id="clickPower-value">1</span></div>
    <div class="hud-item" id="helperTimer"><i class="fas fa-robot"></i> Bobo: <span id="helperTimer-value">‚Äî</span></div>
    <div class="hud-item" id="critChanceInfo"><i class="fas fa-star"></i> –ö—Ä–∏—Ç: <span id="critChance-value">1%</span></div>
    <div class="hud-item" id="critMultiplierInfo"><i class="fas fa-star"></i> –ú–Ω–æ–∂: <span id="critMultiplier-value">x2.0</span></div>
  </div>
  <!-- –ü–†–û–ì–†–ï–°–°-–ë–ê–† –í –¶–ï–ù–¢–†–ï –ü–û–î –ù–ê–ó–í–ê–ù–ò–ï–ú –õ–û–ö–ê–¶–ò–ò -->
  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="progressText">–ü—Ä–æ–≥—Ä–µ—Å—Å: 0.00000 / 0.38710 –∞.–µ. (0%)</div>
  <div id="gameArea"></div>
  <div id="levelAnnounce"></div>
  <!-- –ö–ù–û–ü–ö–ò –£–õ–£–ß–®–ï–ù–ò–ô -->
  <button id="upgradeClickBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-fist-raised"></i>
    <div class="upgrade-cost">80</div>
  </button>
  <button id="upgradeHelperBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-robot"></i>
    <div class="upgrade-cost">1500</div>
  </button>
  <button id="upgradeCritChanceBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-star"></i>
    <div class="upgrade-cost">500</div>
  </button>
  <button id="upgradeCritMultBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-star"></i>
    <div class="upgrade-cost">800</div>
  </button>
  <button id="upgradeHelperDmgBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-bolt"></i>
    <div class="upgrade-cost">1000</div>
  </button>
  <div id="tooltip" class="tooltip"></div>
  <canvas id="particlesCanvas"></canvas>
  <!-- –ó–≤—É–∫–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã -->
  <audio id="clickSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="breakSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="upgradeSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="comboSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="helperSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <div id="welcomeScreen">
    <h2>üöÄ –ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –ö–õ–ò–ö–ï–†</h2>
    <p>–†–∞–∑—Ä—É—à–∞–π—Ç–µ –≤–æ—Å—Ö–æ–¥—è—â–∏–µ –±–ª–æ–∫–∏ –∏ —Å–æ–±–∏—Ä–∞–π—Ç–µ <strong>–∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –ö—Ä–∏—Å—Ç–∞–ª–ª—ã</strong>!</p>
    <p>–ö–∞–∂–¥—ã–π –±–ª–æ–∫ —Ç—Ä–µ–±—É–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–¥–∞—Ä–æ–≤ –¥–ª—è —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è.</p>
    <p><strong>–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:</strong></p>
    <p>üåå <strong>–ê—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã</strong> ‚Äî –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ—Å—å –ø–æ –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ</p>
    <p>ü™ê <strong>9 —Ä–µ–∞–ª—å–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç</strong> ‚Äî –æ—Ç –ú–µ—Ä–∫—É—Ä–∏—è –¥–æ –ü–ª—É—Ç–æ–Ω–∞</p>
    <p>üöÄ <strong>–£–ª—É—á—à–µ–Ω–∏—è</strong> ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Å–∏–ª—É, –∫—Ä–∏—Ç—ã –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –ø–æ–º–æ—â–Ω–∏–∫–∞</p>
    <p>‚ú® <strong>–†–µ–¥–∫–∏–µ –±–ª–æ–∫–∏</strong> ‚Äî –¥–∞—é—Ç –±–æ–Ω—É—Å—ã –∏ –æ–≥—Ä–æ–º–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã!</p>
    <button id="continueBtn" class="btn no-save">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    <button id="startBtn" class="btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  </div>
  <!-- –≠–∫—Ä–∞–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è -->
  <div id="saveScreen">
    <h2>–°–û–•–†–ê–ù–ï–ù–ò–ï –ò–ì–†–´</h2>
    <p>–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é?</p>
    <button id="loadSaveBtn" class="btn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –∏–≥—Ä—É</button>
    <button id="newGameBtn" class="btn">–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É</button>
    <button id="cancelSaveBtn" class="btn" style="background: #666;">–û—Ç–º–µ–Ω–∞</button>
  </div>
  <!-- –≠–∫—Ä–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ -->
  <div id="developmentScreen">
    <h2>üöß –õ–û–ö–ê–¶–ò–Ø –Æ–ü–ò–¢–ï–† –ù–ê–•–û–î–ò–¢–°–Ø –í –†–ê–ó–†–ê–ë–û–¢–ö–ï</h2>
    <p>–í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –≥—Ä–∞–Ω–∏—Ü—ã –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ—Å–º–æ—Å–∞!</p>
    <p>–°–ª–µ–¥—É—é—â–∞—è –ª–æ–∫–∞—Ü–∏—è –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –±—É–¥—É—â–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏.</p>
    <button id="restartFromDevBtn" class="btn">–ù–∞—á–∞—Ç—å –¥–æ–±—ã—á—É –∑–∞–Ω–æ–≤–æ</button>
  </div>
  <div id="gameOverScreen">
    <h2>–î–û–ë–´–ß–ê –ü–†–ï–†–í–ê–ù–ê!</h2>
    <div id="finalScore">–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: 0</div>
    <button id="restartBtn">–ù–æ–≤–∞—è –¥–æ–±—ã—á–∞</button>
    <button id="shareBtn">–ü–æ–¥–µ–ª–∏—Ç—å—Å—è</button>
    <button id="dailyRewardBtn">üéÅ –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞</button>
  </div>
  <script>
    // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –ö–û–î –ü–õ–ê–ù–ï–¢–ê–†–ù–û–ì–û –§–û–ù–ê –° –ü–û–õ–ù–û–¶–ï–ù–ù–´–ú–ò –§–û–ù–ê–ú–ò –î–õ–Ø –ú–û–ë–ò–õ–¨–ù–´–• ===
    (function() {
      const canvas = document.getElementById('planetBackgroundCanvas');
      const ctx = canvas.getContext('2d');
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò - –û–î–ò–ù–ê–ö–û–í–´–ï –î–õ–Ø –í–°–ï–• –£–°–¢–†–û–ô–°–¢–í –î–õ–Ø –ö–†–ê–°–û–ß–ù–û–°–¢–ò
      const fixedSettings = {
        speed: 5,
        density: 5,
        size: 5,
        smoothness: 5,
        nebulaIntensity: 3,
        starDensity: 2
      };
      // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
      let animationId = null;
      let currentPlanet = 'mercury';
      let time = 0;
      // –ú–∞—Å—Å–∏–≤—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∞–Ω–∏–º–∞—Ü–∏–∏
      let particles = [];
      let specialElements = [];
      let nebulae = [];
      let stars = [];
      // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–µ—Ç
      const planetData = {
        mercury: {
          name: '–ú–µ—Ä–∫—É—Ä–∏–π',
          colors: ['#8c7b6b', '#a69b8f', '#5a524c', '#ffaa33', '#ffcc66', '#d9b382', '#bf9e75'],
          background: ['#1a0f0a', '#2c1d14', '#4a3527'],
          type: 'rocky'
        },
        venus: {
          name: '–í–µ–Ω–µ—Ä–∞',
          colors: ['#e6b87e', '#d4a574', '#ff8844', '#b35900', '#ff9966', '#e68a53', '#cc7a3d'],
          background: ['#2a1a0f', '#4a2c1a', '#6b3f20'],
          type: 'cloudy'
        },
        earth: {
          name: '–ó–µ–º–ª—è',
          colors: ['#4a7b9d', '#5d8aa8', '#2e5a78', '#87ceeb', '#a8d5e5', '#6baed6', '#3c8dbc'],
          background: ['#0a1a2a', '#1a2a3a', '#2a3a4a'],
          type: 'oceanic'
        },
        mars: {
          name: '–ú–∞—Ä—Å',
          colors: ['#cd5c5c', '#a52a2a', '#8b4513', '#ff6347', '#e2583e', '#c14533', '#a33226'],
          background: ['#2a0f0a', '#4a1a14', '#6b251e'],
          type: 'dusty'
        },
        jupiter: {
          name: '–Æ–ø–∏—Ç–µ—Ä',
          colors: ['#d2b48c', '#bc8f8f', '#a0522d', '#ff7f50', '#e67347', '#cc663d', '#b35933'],
          background: ['#2a1f14', '#4a3728', '#6b4f3c'],
          type: 'stormy'
        },
        saturn: {
          name: '–°–∞—Ç—É—Ä–Ω',
          colors: ['#f0e68c', '#daa520', '#b8860b', '#ffd700', '#e6c347', '#ccaa3d', '#b39233'],
          background: ['#2a2414', '#4a3c28', '#6b543c'],
          type: 'ringed'
        },
        uranus: {
          name: '–£—Ä–∞–Ω',
          colors: ['#afeeee', '#7fffd4', '#40e0d0', '#48d1cc', '#3dc4bf', '#32b7b2', '#27aaa5'],
          background: ['#0a1a2a', '#1a2a3a', '#2a3a4a'],
          type: 'icy'
        },
        neptune: {
          name: '–ù–µ–ø—Ç—É–Ω',
          colors: ['#4169e1', '#0000cd', '#191970', '#1e90ff', '#1a7feb', '#166fd7', '#125fc3'],
          background: ['#0a0a2a', '#1a1a3a', '#2a2a4a'],
          type: 'windy'
        },
        pluto: {
          name: '–ü–ª—É—Ç–æ–Ω',
          colors: ['#a9a9a9', '#696969', '#808080', '#d3d3d3', '#c0c0c0', '#b0b0b0', '#9e9e9e'],
          background: ['#1a1a2a', '#2a2a3a', '#3a3a4a'],
          type: 'dwarf'
        }
      };
      // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ canvas
      function setCanvasSize() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        if (isMobile) {
          const pixelRatio = window.devicePixelRatio || 1;
          canvas.width = canvas.offsetWidth * pixelRatio;
          canvas.height = canvas.offsetHeight * pixelRatio;
          ctx.scale(pixelRatio, pixelRatio);
        }
      }
      // –ö–ª–∞—Å—Å —á–∞—Å—Ç–∏—Ü
      class Particle {
        constructor(x, y, radius, color, velocity, type) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.color = color;
          this.velocity = velocity;
          this.alpha = 1;
          this.type = type;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.02;
          this.pulse = Math.random() * Math.PI * 2;
          this.twinkle = Math.random() * Math.PI * 2;
          this.twinkleSpeed = 0.05 + Math.random() * 0.05;
          this.lifetime = 1;
          this.maxLifetime = 1;
        }
        draw() {
          ctx.save();
          if (this.type === 'star') {
            const twinkleFactor = 0.7 + 0.3 * Math.sin(this.twinkle);
            ctx.globalAlpha = this.alpha * twinkleFactor * this.lifetime;
          } else if (this.type === 'ice') {
            ctx.globalAlpha = this.alpha * this.lifetime;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI) / 3;
              const x = Math.cos(angle) * this.radius;
              const y = Math.sin(angle) * this.radius;
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
            return;
          } else {
            ctx.globalAlpha = this.alpha * this.lifetime;
          }
          ctx.translate(this.x, this.y);
          if (this.type === 'ring') {
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.ellipse(0, 0, this.radius, this.radius/3, 0, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
          } else if (this.type === 'nebula') {
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            gradient.addColorStop(0, this.color + 'aa');
            gradient.addColorStop(1, this.color + '00');
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
          } else if (this.type === 'crystal') {
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.moveTo(0, -this.radius);
            ctx.lineTo(this.radius/2, 0);
            ctx.lineTo(0, this.radius);
            ctx.lineTo(-this.radius/2, 0);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
          } else {
            const pulseFactor = 0.8 + 0.2 * Math.sin(this.pulse);
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * pulseFactor, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
          }
          ctx.restore();
        }
        update() {
          this.draw();
          if (this.type === 'ice' || this.type === 'crystal') {
            this.lifetime = Math.min(1, this.lifetime + 0.02);
          }
          const smoothFactor = fixedSettings.smoothness / 10;
          this.velocity.x *= (1 - smoothFactor * 0.05);
          this.velocity.y *= (1 - smoothFactor * 0.05);
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          this.rotation += this.rotationSpeed;
          this.pulse += 0.05;
          this.twinkle += this.twinkleSpeed;
          if (this.x < -this.radius * 2) {
            this.x = canvas.width + this.radius;
            this.lifetime = 0;
          } else if (this.x > canvas.width + this.radius * 2) {
            this.x = -this.radius;
            this.lifetime = 0;
          }
          if (this.y < -this.radius * 2) {
            this.y = canvas.height + this.radius;
            this.lifetime = 0;
          } else if (this.y > canvas.height + this.radius * 2) {
            this.y = -this.radius;
            this.lifetime = 0;
          }
        }
      }
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ —Ñ–æ–Ω–∞
      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        const bgColors = planetData[currentPlanet].background;
        gradient.addColorStop(0, bgColors[0]);
        gradient.addColorStop(0.5, bgColors[1]);
        gradient.addColorStop(1, bgColors[2]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–≤–µ–∑–¥
      function generateStars() {
        const starCount = fixedSettings.starDensity * 50;
        stars = [];
        for (let i = 0; i < starCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 1.5 + 0.5;
          const starColors = ['#ffffff', '#f8f8ff', '#e6e6fa', '#fffacd', '#f0f8ff'];
          const color = starColors[Math.floor(Math.random() * starColors.length)];
          const velocity = {
            x: 0,
            y: 0
          };
          stars.push(new Particle(x, y, radius, color, velocity, 'star'));
        }
      }
      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—É–º–∞–Ω–Ω–æ—Å—Ç–µ–π
      function generateNebulae() {
        const nebulaCount = fixedSettings.nebulaIntensity;
        nebulae = [];
        for (let i = 0; i < nebulaCount; i++) {
          const aspectRatio = canvas.width / canvas.height;
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 200 + (aspectRatio > 1 ? 80 : 120);
          const planetColors = planetData[currentPlanet].colors;
          const color = planetColors[Math.floor(Math.random() * planetColors.length)];
          const velocity = {
            x: (Math.random() - 0.5) * 0.05,
            y: (Math.random() - 0.5) * 0.05
          };
          nebulae.push(new Particle(x, y, radius, color, velocity, 'nebula'));
        }
      }
      // –§—É–Ω–∫—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–ª–∞–Ω–µ—Ç—ã
      function generateMercury() {
        const particleCount = fixedSettings.density * 15;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 1;
          const color = planetData.mercury.colors[Math.floor(Math.random() * planetData.mercury.colors.length)];
          const speedValue = (Math.random() * 0.5 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'rock'));
        }
        for (let i = 0; i < 5; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 20 + 10;
          const color = planetData.mercury.colors[3];
          const velocity = {
            x: 0,
            y: 0
          };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'sun'));
        }
      }
      function generateVenus() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 3 + 5;
          const color = planetData.venus.colors[Math.floor(Math.random() * planetData.venus.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + Math.PI / 2;
          const velocity = {
            x: Math.cos(angle) * speedValue * (distance / 100),
            y: Math.sin(angle) * speedValue * (distance / 100)
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'cloud'));
        }
      }
      function generateEarth() {
        const particleCount = fixedSettings.density * 25;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 2;
          const color = planetData.earth.colors[Math.floor(Math.random() * planetData.earth.colors.length)];
          const speedValue = (Math.random() * 0.5 + 0.2) * fixedSettings.speed / 5;
          const angle = Math.random() > 0.5 ? 
            Math.PI / 2 + (Math.random() - 0.5) * 0.5 : 
            -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'water'));
        }
      }
      function generateMars() {
        const particleCount = fixedSettings.density * 30;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size + 1;
          const color = planetData.mars.colors[Math.floor(Math.random() * planetData.mars.colors.length)];
          const speedValue = (Math.random() * 1 + 0.5) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'dust'));
        }
      }
      function generateJupiter() {
        const particleCount = fixedSettings.density * 15;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 4 + 10;
          const color = planetData.jupiter.colors[Math.floor(Math.random() * planetData.jupiter.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.1) * fixedSettings.speed / 5;
          const direction = Math.random() > 0.5 ? 1 : -1;
          const velocity = {
            x: speedValue * direction,
            y: 0
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'storm'));
        }
        const x = canvas.width * 0.7;
        const y = canvas.height * 0.5;
        const radius = 50;
        const color = planetData.jupiter.colors[3];
        const velocity = {
          x: -0.1 * fixedSettings.speed / 5,
          y: 0
        };
        specialElements.push(new Particle(x, y, radius, color, velocity, 'spot'));
      }
      function generateSaturn() {
        const particleCount = fixedSettings.density * 10;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 100 + Math.random() * 150;
          const x = canvas.width / 2 + Math.cos(angle) * distance;
          const y = canvas.height / 2 + Math.sin(angle) * distance;
          const radius = Math.random() * fixedSettings.size * 2 + 5;
          const color = planetData.saturn.colors[Math.floor(Math.random() * planetData.saturn.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const orbitalAngle = angle + Math.PI / 2;
          const velocity = {
            x: Math.cos(orbitalAngle) * speedValue,
            y: Math.sin(orbitalAngle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'ring'));
        }
        for (let i = 0; i < fixedSettings.density * 5; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 3 + 5;
          const color = planetData.saturn.colors[Math.floor(Math.random() * planetData.saturn.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'cloud'));
        }
      }
      function generateUranus() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 3;
          const color = planetData.uranus.colors[Math.floor(Math.random() * planetData.uranus.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.05) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'ice'));
        }
      }
      function generateNeptune() {
        const particleCount = fixedSettings.density * 25;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size + 2;
          const color = planetData.neptune.colors[Math.floor(Math.random() * planetData.neptune.colors.length)];
          const speedValue = (Math.random() * 0.8 + 0.3) * fixedSettings.speed / 5;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + Math.PI / 2;
          const velocity = {
            x: Math.cos(angle) * speedValue * (1 + distance / 200),
            y: Math.sin(angle) * speedValue * (1 + distance / 200)
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'wind'));
        }
        for (let i = 0; i < 3; i++) {
          const x = canvas.width * (0.2 + i * 0.3);
          const y = canvas.height * 0.5;
          const radius = 30 + Math.random() * 20;
          const color = planetData.neptune.colors[2];
          const velocity = {
            x: 0.2 * fixedSettings.speed / 5,
            y: 0
          };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'spot'));
        }
      }
      function generatePluto() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 1.5 + 2;
          const color = planetData.pluto.colors[Math.floor(Math.random() * planetData.pluto.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          if (i % 3 === 0) {
            particles.push(new Particle(x, y, radius, color, velocity, 'ice'));
          } else if (i % 3 === 1) {
            particles.push(new Particle(x, y, radius, color, velocity, 'crystal'));
          } else {
            particles.push(new Particle(x, y, radius, color, velocity, 'rock'));
          }
        }
        for (let i = 0; i < 3; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 30 + 20;
          const color = planetData.pluto.colors[3];
          const velocity = {
            x: (Math.random() - 0.5) * 0.1,
            y: (Math.random() - 0.5) * 0.1
          };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'ice'));
        }
      }
      // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
      function animateParticles() {
        drawBackground();
        nebulae.forEach(nebula => {
          nebula.update();
        });
        stars.forEach(star => {
          star.update();
        });
        particles.forEach(particle => {
          particle.update();
        });
        specialElements.forEach(element => {
          element.update();
        });
      }
      // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
      function animate() {
        time += 0.01;
        animateParticles();
        animationId = requestAnimationFrame(animate);
      }
      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–æ–Ω–∞ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –ø–ª–∞–Ω–µ—Ç—ã
      function generatePlanetBackground() {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        particles = [];
        specialElements = [];
        nebulae = [];
        stars = [];
        generateStars();
        generateNebulae();
        const genMap = {
          mercury: generateMercury,
          venus: generateVenus,
          earth: generateEarth,
          mars: generateMars,
          jupiter: generateJupiter,
          saturn: generateSaturn,
          uranus: generateUranus,
          neptune: generateNeptune,
          pluto: generatePluto
        };
        genMap[currentPlanet]();
        animate();
      }
      // –°–º–µ–Ω–∞ –ø–ª–∞–Ω–µ—Ç—ã
      function changePlanet(planet) {
        currentPlanet = planet;
        generatePlanetBackground();
      }
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
      function init() {
        setCanvasSize();
        generatePlanetBackground();
        window.addEventListener('resize', setCanvasSize);
      }
      // –ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã
      window.planetBackground = {
        init: init,
        setPlanet: changePlanet,
        setCanvasSize: setCanvasSize
      };
    })();
    // === –ö–û–î –ò–ì–†–´ ===
    document.addEventListener('DOMContentLoaded', function() {
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω–æ–≥–æ —Ñ–æ–Ω–∞
        planetBackground.init();
        // –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –∏–≥—Ä—ã
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        // === –§–ê–ö–¢–ò–ß–ï–°–ö–ò–ï –†–ê–°–°–¢–û–Ø–ù–ò–Ø –ü–õ–ê–ù–ï–¢ –í –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–• –ï–î–ò–ù–ò–¶–ê–• ===
        // 1 –∞.–µ. = 149,597,870.691 –∫–º
        const astronomicalUnits = {
            mercury: 0.38710,
            venus: 0.72333,
            earth: 1.00000,
            mars: 1.52366,
            jupiter: 5.20336,
            saturn: 9.53707,
            uranus: 19.19126,
            neptune: 30.06896,
            pluto: 39.48200
        };
        // –ü–ï–†–ï–°–ß–ò–¢–ê–ù–û –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–π –∞—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–æ–π –µ–¥–∏–Ω–∏—Ü—ã
        const AU_TO_DAMAGE = 149597870.691;
        const locationRequirements = {
            mercury: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.mercury,
                nextLocation: 'venus'
            },
            venus: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.venus,
                nextLocation: 'earth'
            },
            earth: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.earth,
                nextLocation: 'mars'
            },
            mars: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.mars,
                nextLocation: 'jupiter'
            },
            jupiter: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.jupiter,
                nextLocation: 'saturn'
            },
            saturn: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.saturn,
                nextLocation: 'uranus'
            },
            uranus: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.uranus,
                nextLocation: 'neptune'
            },
            neptune: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.neptune,
                nextLocation: 'pluto'
            },
            pluto: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.pluto,
                nextLocation: null
            }
        };
        let blockSpeed = isMobile ? 25 : 20;
        function getCurrentSpeed() {
            const baseSpeed = blockSpeed;
            const locationIndex = Object.keys(locationRequirements).indexOf(currentLocation);
            if (locationIndex < 3) {
                return baseSpeed * 0.85;
            }
            return baseSpeed;
        }
        const baseClickUpgradeCost = 80;
        const baseHelperUpgradeCost = 1500;
        const baseCritChanceCost = 500;
        const baseCritMultiplierCost = 800;
        const baseHelperDmgCost = 1000;
        const rareBlocks = {
            GOLD: {
                name: "–ó–æ–ª–æ—Ç–æ–π",
                chance: 0.03,
                multiplier: 8,
                healthMultiplier: 1.8,
                effect: "–ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å",
                className: "block-gold"
            },
            RAINBOW: {
                name: "–†–∞–¥—É–∂–Ω—ã–π", 
                chance: 0.02,
                multiplier: 5,
                healthMultiplier: 1.5,
                effect: "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–∏–ª—ã",
                className: "block-rainbow"
            },
            CRYSTAL: {
                name: "–ö—Ä–∏—Å—Ç–∞–ª—å–Ω—ã–π",
                chance: 0.025,
                multiplier: 6,
                healthMultiplier: 1.6,
                effect: "–í—Ä–µ–º—è –ø–æ–º–æ—â–Ω–∏–∫–∞",
                className: "block-crystal"
            },
            MYSTERY: {
                name: "–ó–∞–≥–∞–¥–æ—á–Ω—ã–π",
                chance: 0.015,
                multiplier: 10,
                healthMultiplier: 2.0,
                effect: "–°–ª—É—á–∞–π–Ω—ã–π –±–æ–Ω—É—Å",
                className: "block-mystery"
            }
        };
        const balanceConfig = {
            baseHealth: 80,
            targetClicks: 70,
            healthRandomRange: { min: 0.8, max: 1.3 },
            damageProgression: {
                baseMultiplier: 1.15,
                diminishingReturns: 0.96,
                maxLevelEffect: 60
            },
            rewardMultiplier: 2.5,
            comboMultiplier: 0.25,
            randomBonusRange: { min: 0.8, max: 1.5 }
        };
        // –û–±—ä—è–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–π
        let stars = [], lavaParticles = [], snowflakes = [], bioDots = [];
        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
        let coins = 0;
        let totalDamageDealt = 0;
        let clickPower = 1;
        let clickUpgradeLevel = 0;
        let gameActive = false;
        let currentLocation = 'mercury';
        let currentBlockHealth = 0;
        let currentBlock = null;
        let comboCount = 0;
        let lastDestroyTime = 0;
        const COMBO_TIME_WINDOW = isMobile ? 1500 : 2000;
        let helperActive = false;
        let helperTimeLeft = 0;
        const helperDuration = 60000;
        let helperInterval;
        let helperUpgradeLevel = 0;
        const helperUpgradeMultiplier = 1.8;
        let critChance = 0.01;
        let critMultiplier = 2.0;
        let helperDamageBonus = 0.3;
        let helperElement = null;
        let helperPosition = { x: 0, y: 0 };
        const gameMetrics = {
            startTime: Date.now(),
            blocksDestroyed: 0,
            upgradesBought: 0,
            totalClicks: 0,
            sessions: parseInt(localStorage.getItem('gameSessions') || '0') + 1
        };
        // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –ë–ê–õ–ê–ù–°–ò–†–û–í–ö–ò ===
        function calculateBlockHealth() {
            const location = locationRequirements[currentLocation];
            const locationBonus = 1 + (location.targetAU * 2);
            let baseHealth = balanceConfig.baseHealth * locationBonus;
            const targetHealth = clickPower * balanceConfig.targetClicks;
            const combinedHealth = (baseHealth + targetHealth) / 2;
            const randomFactor = balanceConfig.healthRandomRange.min + 
                                Math.random() * (balanceConfig.healthRandomRange.max - balanceConfig.healthRandomRange.min);
            return Math.floor(combinedHealth * randomFactor);
        }
        function calculateClickPower() {
            const basePower = 1;
            const upgradeBonus = clickUpgradeLevel;
            const diminishingEffect = Math.pow(balanceConfig.damageProgression.diminishingReturns, 
                                             Math.min(clickUpgradeLevel, balanceConfig.damageProgression.maxLevelEffect));
            const nonLinearGrowth = Math.sqrt(clickUpgradeLevel + 1);
            return basePower + (upgradeBonus * diminishingEffect * nonLinearGrowth * balanceConfig.damageProgression.baseMultiplier);
        }
        function getExpectedClicks(blockHealth, playerDamage) {
            return Math.ceil(blockHealth / playerDamage);
        }
        function getRareBlockType() {
            const rand = Math.random();
            let cumulativeChance = 0;
            for (const [type, block] of Object.entries(rareBlocks)) {
                cumulativeChance += block.chance;
                if (rand <= cumulativeChance) {
                    return type;
                }
            }
            return null;
        }
        function announceRareBlock(blockName) {
            const announce = document.createElement('div');
            announce.className = 'rare-block-announce';
            announce.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 1.8em;
                font-weight: bold;
                color: gold;
                z-index: 50;
                text-shadow: 0 0 10px black;
                animation: fadeInOut 2s;
            `;
            announce.textContent = `üåü ${blockName} –±–ª–æ–∫! üåü`;
            document.body.appendChild(announce);
            setTimeout(() => {
                if (announce.parentNode) {
                    document.body.removeChild(announce);
                }
            }, 2000);
        }
        // === –£–õ–£–ß–®–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –°–û–•–†–ê–ù–ï–ù–ò–Ø ===
        function saveGame() {
          const saveData = {
            coins,
            clickPower,
            clickUpgradeLevel,
            critChance,
            critMultiplier,
            helperDamageBonus,
            helperUpgradeLevel,
            totalDamageDealt,
            currentLocation,
            lastDailyReward: localStorage.getItem('lastDailyReward'),
            gameActive: true,
            timestamp: Date.now()
          };
          localStorage.setItem('cosmicBlocksSave', JSON.stringify(saveData));
          showTooltip('–ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!');
          setTimeout(hideTooltip, 1500);
          updateContinueButton();
        }
        function loadGame() {
          const saved = localStorage.getItem('cosmicBlocksSave');
          if (saved) {
            try {
              const data = JSON.parse(saved);
              const saveAge = Date.now() - (data.timestamp || 0);
              const maxSaveAge = 30 * 24 * 60 * 60 * 1000;
              if (saveAge < maxSaveAge) {
                coins = data.coins || 0;
                clickPower = data.clickPower || 1;
                clickUpgradeLevel = data.clickUpgradeLevel || 0;
                critChance = data.critChance || 0.01;
                critMultiplier = data.critMultiplier || 2.0;
                helperDamageBonus = data.helperDamageBonus || 0.3;
                helperUpgradeLevel = data.helperUpgradeLevel || 0;
                totalDamageDealt = data.totalDamageDealt || 0;
                currentLocation = data.currentLocation || 'mercury';
                return true;
              } else {
                console.log('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ');
                localStorage.removeItem('cosmicBlocksSave');
              }
            } catch (e) {
              console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', e);
            }
          }
          return false;
        }
        function updateContinueButton() {
          const continueBtn = document.getElementById('continueBtn');
          if (continueBtn) {
            const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
            if (hasSave) {
              continueBtn.className = 'btn save-available';
              continueBtn.textContent = '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å';
            } else {
              continueBtn.className = 'btn no-save';
              continueBtn.textContent = '–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è';
            }
          }
        }
        function checkDailyReward() {
          const now = Date.now();
          const last = localStorage.getItem('lastDailyReward');
          if (!last || now - parseInt(last) >= 24 * 60 * 60 * 1000) {
            coins += 1000;
            updateCoins();
            localStorage.setItem('lastDailyReward', now.toString());
            showTooltip('üéÅ +1000 –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤!');
            setTimeout(hideTooltip, 2000);
            saveGame();
            return true;
          } else {
            const hoursLeft = Math.ceil((24 * 60 * 60 * 1000 - (now - parseInt(last))) / (1000 * 60 * 60));
            showTooltip(`–ù–∞–≥—Ä–∞–¥–∞ —á–µ—Ä–µ–∑ ${hoursLeft} —á.`);
            setTimeout(hideTooltip, 2000);
            return false;
          }
        }
        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã DOM
        const DOMElements = {
            coinsDisplay: document.getElementById("coins-value"),
            clickPowerDisplay: document.getElementById("clickPower-value"),
            helperTimerDisplay: document.getElementById("helperTimer-value"),
            critChanceDisplay: document.getElementById("critChance-value"),
            critMultiplierDisplay: document.getElementById("critMultiplier-value"),
            progressBar: document.getElementById("progressBar"),
            progressText: document.getElementById("progressText"),
            levelAnnounce: document.getElementById("levelAnnounce"),
            gameTitle: document.getElementById("gameTitle"),
            upgradeClickBtn: document.getElementById("upgradeClickBtn"),
            upgradeHelperBtn: document.getElementById("upgradeHelperBtn"),
            upgradeCritChanceBtn: document.getElementById("upgradeCritChanceBtn"),
            upgradeCritMultBtn: document.getElementById("upgradeCritMultBtn"),
            upgradeHelperDmgBtn: document.getElementById("upgradeHelperDmgBtn"),
            gameOverScreen: document.getElementById("gameOverScreen"),
            developmentScreen: document.getElementById("developmentScreen"),
            finalScoreDisplay: document.getElementById("finalScore"),
            tooltip: document.getElementById("tooltip"),
            welcomeScreen: document.getElementById("welcomeScreen"),
            saveScreen: document.getElementById("saveScreen"),
            header: document.getElementById("header"),
            gameArea: document.getElementById("gameArea"),
            particlesCanvas: document.getElementById("particlesCanvas"),
            startBtn: document.getElementById("startBtn"),
            continueBtn: document.getElementById("continueBtn"),
            loadSaveBtn: document.getElementById("loadSaveBtn"),
            newGameBtn: document.getElementById("newGameBtn"),
            cancelSaveBtn: document.getElementById("cancelSaveBtn"),
            restartBtn: document.getElementById("restartBtn"),
            restartFromDevBtn: document.getElementById("restartFromDevBtn"),
            shareBtn: document.getElementById("shareBtn"),
            dailyRewardBtn: document.getElementById("dailyRewardBtn"),
            saveBtn: document.getElementById("saveBtn")
        };
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        let missingElements = [];
        Object.entries(DOMElements).forEach(([name, element]) => {
            if (!element) missingElements.push(name);
        });
        if (missingElements.length > 0) {
            console.error("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —ç–ª–µ–º–µ–Ω—Ç—ã:", missingElements.join(", "));
            return;
        }
        // –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        const {
            coinsDisplay, clickPowerDisplay, helperTimerDisplay, 
            critChanceDisplay, critMultiplierDisplay, progressBar, progressText,
            levelAnnounce, gameTitle, upgradeClickBtn, upgradeHelperBtn, 
            upgradeCritChanceBtn, upgradeCritMultBtn, upgradeHelperDmgBtn, 
            gameOverScreen, developmentScreen, finalScoreDisplay, tooltip, welcomeScreen, saveScreen,
            header, gameArea, particlesCanvas, startBtn, continueBtn, loadSaveBtn,
            newGameBtn, cancelSaveBtn, restartBtn, restartFromDevBtn, shareBtn, dailyRewardBtn, saveBtn
        } = DOMElements;
        // –ó–ê–ì–†–£–ó–ö–ê –°–û–•–†–ê–ù–ï–ù–ò–Ø –ü–†–ò –°–¢–ê–†–¢–ï –ò –û–ë–ù–û–í–õ–ï–ù–ò–ï –ö–ù–û–ü–ö–ò –ü–†–û–î–û–õ–ñ–ò–¢–¨
        updateContinueButton();
        // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –≠–§–§–ï–ö–¢ –í–ó–†–´–í–ê –° –£–í–ï–õ–ò–ß–ï–ù–ù–û–ô –û–ë–õ–ê–°–¢–¨–Æ ===
        function createExplosion(block) {
            const rect = block.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            // –£–í–ï–õ–ò–ß–ï–ù–ù–´–ô –†–ê–ó–ú–ï–† –í–ó–†–´–í–ê
            const explosionSize = isMobile ? 150 : 200;
            // –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∑—Ä—ã–≤
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.left = centerX + 'px';
            explosion.style.top = centerY + 'px';
            explosion.style.width = explosionSize + 'px';
            explosion.style.height = explosionSize + 'px';
            document.body.appendChild(explosion);
            // –£–í–ï–õ–ò–ß–ï–ù–ù–û–ï –ö–û–õ–ò–ß–ï–°–¢–í–û –ß–ê–°–¢–ò–¶
            const particleCount = isMobile ? 20 : 25;
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'explosion-particle';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                // –£–í–ï–õ–ò–ß–ï–ù–ù–´–ô –†–ê–ó–ú–ï–† –ß–ê–°–¢–ò–¶
                const particleSize = isMobile ? 10 : 12;
                particle.style.width = particleSize + 'px';
                particle.style.height = particleSize + 'px';
                const location = locations[currentLocation];
                particle.style.backgroundColor = location.blockColors[Math.floor(Math.random() * location.blockColors.length)];
                // –£–í–ï–õ–ò–ß–ï–ù–ù–û–ï –†–ê–°–°–¢–û–Ø–ù–ò–ï –†–ê–ó–õ–ï–¢–ê
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                document.body.appendChild(particle);
                // –£–¥–∞–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 800);
            }
            // –£–¥–∞–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∑—Ä—ã–≤ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
            setTimeout(() => {
                if (explosion.parentNode) {
                    document.body.removeChild(explosion);
                }
            }, 600);
        }
        const locations = {
            mercury: { name: "‚òø –ú–µ—Ä–∫—É—Ä–∏–π", color: "#bb86fc", coinColor: "#a0d2ff", borderColor: "#4a55e0", blockColors: ['#2962ff', '#4fc3f7', '#bb86fc', '#f8bbd0'] },
            venus: { name: "‚ôÄ –í–µ–Ω–µ—Ä–∞", color: "#ffab91", coinColor: "#a0d2ff", borderColor: "#ff5722", blockColors: ['#ff5722', '#ff9800', '#ff5722', '#e91e63'] },
            earth: { name: "‚ôÅ –ó–µ–º–ª—è", color: "#80deea", coinColor: "#a0d2ff", borderColor: "#0288d1", blockColors: ['#0288d1', '#29b6f6', '#00bcd4', '#00e5ff'] },
            mars: { name: "‚ôÇ –ú–∞—Ä—Å", color: "#a5d6a7", coinColor: "#a0d2ff", borderColor: "#388e3c", blockColors: ['#388e3c', '#66bb6a', '#9ccc65', '#d4e157'] },
            jupiter: { name: "‚ôÉ –Æ–ø–∏—Ç–µ—Ä", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            saturn: { name: "‚ôÑ –°–∞—Ç—É—Ä–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            uranus: { name: "‚ôÖ –£—Ä–∞–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            neptune: { name: "‚ôÜ –ù–µ–ø—Ç—É–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            pluto: { name: "‚ôá –ü–ª—É—Ç–æ–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] }
        };
        // === –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–†–û–ì–†–ï–°–°–ê –í –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–• –ï–î–ò–ù–ò–¶–ê–• ===
        function updateProgressBar() {
            const currentReq = locationRequirements[currentLocation];
            const nextLocation = currentReq.nextLocation;
            const currentAU = totalDamageDealt / AU_TO_DAMAGE;
            const targetAU = currentReq.targetAU;
            const percentage = Math.min(100, (currentAU / targetAU) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = `–ü—Ä–æ–≥—Ä–µ—Å—Å: ${currentAU.toFixed(5)} / ${targetAU.toFixed(5)} –∞.–µ. (${percentage.toFixed(1)}%)`;
        }
        function checkLocationUpgrade() {
            const currentReq = locationRequirements[currentLocation];
            const nextLocation = currentReq.nextLocation;
            const currentAU = totalDamageDealt / AU_TO_DAMAGE;
            const targetAU = currentReq.targetAU;
            if (nextLocation && currentAU >= targetAU) {
                if (nextLocation === 'jupiter') {
                    showDevelopmentScreen();
                    return;
                }
                setLocation(nextLocation);
                showTooltip(`–û—Ç–∫—Ä—ã—Ç–∞ –ª–æ–∫–∞—Ü–∏—è: ${locations[nextLocation].name}!`);
                setTimeout(hideTooltip, 3000);
            }
            updateProgressBar();
        }
        function showDevelopmentScreen() {
            if (developmentScreen) {
                developmentScreen.style.display = "flex";
                gameActive = false;
            }
        }
        // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –¢–ï–ö–°–¢–ê –£–†–û–ù–ê –ò –ë–û–ù–£–°–û–í ===
        function createDamageText(damage, block, color = '#ff4444') {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'damage-text';
            text.textContent = `-${damage}`;
            text.style.color = color;
            let left = rect.left + rect.width / 2;
            let top = rect.top;
            const textWidth = 100;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            document.body.appendChild(text);
            let opacity = 1;
            let yPos = parseInt(text.style.top);
            function animate() {
                opacity -= 0.02;
                yPos -= 2;
                text.style.opacity = opacity;
                text.style.top = yPos + 'px';
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    if (text.parentNode) {
                        document.body.removeChild(text);
                    }
                }
            }
            animate();
        }
        function showComboText(combo, bonus, block) {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'combo-text';
            text.textContent = `–ö–æ–º–±–æ x${combo}! +${bonus}`;
            let left = rect.left + rect.width / 2;
            let top = rect.top;
            const textWidth = 150;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            document.body.appendChild(text);
            setTimeout(() => {
                if (text.parentNode) {
                    document.body.removeChild(text);
                }
            }, 1000);
        }
        function showRewardText(reward, block) {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'reward-text';
            text.textContent = `+${reward} üíé`;
            let left = rect.left + rect.width / 2;
            let top = rect.top + rect.height / 2;
            const textWidth = 120;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            document.body.appendChild(text);
            setTimeout(() => {
                if (text.parentNode) {
                    document.body.removeChild(text);
                }
            }, 1500);
        }
        // === –§–£–ù–ö–¶–ò–ò –†–ê–ë–û–¢–´ –° –ü–û–ú–û–©–ù–ò–ö–û–ú BOBO ===
        function moveHelperToRandomPosition() {
            if (!helperElement) return;
            
            // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é —Ç–µ–∫—É—â–µ–≥–æ –±–ª–æ–∫–∞
            let blockRect = { left: window.innerWidth/2, top: window.innerHeight/2 };
            if (currentBlock) {
                blockRect = currentBlock.getBoundingClientRect();
            }
            
            // –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –≤–¥–∞–ª–∏ –æ—Ç –±–ª–æ–∫–∞
            let attempts = 0;
            let validPosition = false;
            const safeDistance = 150;
            
            while (!validPosition && attempts < 20) {
                attempts++;
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                const randomX = Math.random() * (window.innerWidth - 60) + 30;
                const randomY = Math.random() * (window.innerHeight - 120) + 60; // –ò–∑–±–µ–≥–∞–µ–º –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ —Å UI
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –±–ª–æ–∫–∞
                const distance = Math.sqrt(
                    Math.pow(randomX - (blockRect.left + blockRect.width/2), 2) + 
                    Math.pow(randomY - (blockRect.top + blockRect.height/2), 2)
                );
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–∑–∏—Ü–∏—è –Ω–µ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∫—Ä–∞—è–º –∏ –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç UI
                const safeFromEdges = randomX > 60 && randomX < window.innerWidth - 60 && 
                                    randomY > 100 && randomY < window.innerHeight - 60;
                
                if (distance > safeDistance && safeFromEdges) {
                    helperPosition = { x: randomX, y: randomY };
                    validPosition = true;
                }
            }
            
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Ö–æ—Ä–æ—à—É—é –ø–æ–∑–∏—Ü–∏—é, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∏–ª–∏ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é
            if (!validPosition) {
                helperPosition = {
                    x: window.innerWidth * 0.7,
                    y: window.innerHeight * 0.7
                };
            }
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
            helperElement.style.left = helperPosition.x + 'px';
            helperElement.style.top = helperPosition.y + 'px';
        }

        function createHelperElement() {
            if (helperElement && helperElement.parentNode) {
                document.body.removeChild(helperElement);
            }
            
            helperElement = document.createElement('div');
            helperElement.className = 'helper';
            
            document.body.appendChild(helperElement);
            moveHelperToRandomPosition();
            
            // –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ
            helperElement.style.opacity = '0';
            setTimeout(() => {
                if (helperElement) helperElement.style.opacity = '1';
            }, 100);
        }

        function activateHelper() {
            if (helperActive) return;
            helperActive = true;
            helperTimeLeft = helperDuration;
            
            // –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ–º–æ—â–Ω–∏–∫–∞
            createHelperElement();
            
            helperInterval = setInterval(() => {
                if (helperActive && currentBlock && gameActive) {
                    helperAttack();
                }
            }, 1500);
            
            const helperTimer = setInterval(() => {
                if (!helperActive) {
                    clearInterval(helperTimer);
                    return;
                }
                helperTimeLeft -= 1000;
                updateHelperTimer();
                if (helperTimeLeft <= 0) {
                    helperActive = false;
                    clearInterval(helperInterval);
                    clearInterval(helperTimer);
                    
                    // –ü–ª–∞–≤–Ω–æ–µ –∏—Å—á–µ–∑–∞–Ω–∏–µ –ø–æ–º–æ—â–Ω–∏–∫–∞
                    if (helperElement) {
                        helperElement.style.opacity = '0';
                        setTimeout(() => {
                            if (helperElement && helperElement.parentNode) {
                                document.body.removeChild(helperElement);
                                helperElement = null;
                            }
                        }, 300);
                    }
                    
                    updateUpgradeButtons();
                    showTooltip('Bobo –∑–∞–∫–æ–Ω—á–∏–ª —Ä–∞–±–æ—Ç—É!');
                    setTimeout(hideTooltip, 1500);
                }
            }, 1000);
            
            updateUpgradeButtons();
            showTooltip('Bobo –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 1 –º–∏–Ω—É—Ç—É!');
            setTimeout(hideTooltip, 1500);
        }

        function helperAttack() {
            if (!currentBlock || !helperActive || !helperElement) return;
            
            // –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –∞—Ç–∞–∫–∏
            createHelperEffect();
            
            const baseHelperDmg = clickPower * (1 + helperDamageBonus);
            const upgradedHelperDmg = baseHelperDmg * (1 + helperUpgradeLevel * 0.2);
            currentBlockHealth -= upgradedHelperDmg;
            totalDamageDealt += upgradedHelperDmg;
            gameMetrics.totalClicks++;
            
            createDamageText(Math.round(upgradedHelperDmg), currentBlock, '#69f0ae');
            checkLocationUpgrade();
            
            if (currentBlockHealth <= 0) {
                destroyBlock(currentBlock);
            } else {
                currentBlock.textContent = Math.floor(currentBlockHealth);
                updateCracks(currentBlock, currentBlockHealth);
            }
        }

        function createHelperEffect() {
            if (!currentBlock || !helperElement) return;
            
            const blockRect = currentBlock.getBoundingClientRect();
            const helperRect = helperElement.getBoundingClientRect();
            
            const beam = document.createElement('div');
            beam.className = 'helper-beam';
            beam.style.left = helperRect.left + 15 + 'px';
            beam.style.top = helperRect.top + 30 + 'px';
            beam.style.width = '2px';
            beam.style.height = '0';
            
            document.body.appendChild(beam);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –ª—É—á–∞
            const animateBeam = () => {
                const currentHeight = parseInt(beam.style.height) || 0;
                const targetHeight = blockRect.top - (helperRect.top + 30);
                
                if (currentHeight < targetHeight) {
                    beam.style.height = (currentHeight + 5) + 'px';
                    requestAnimationFrame(animateBeam);
                } else {
                    // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è
                    const hitEffect = document.createElement('div');
                    hitEffect.style.position = 'absolute';
                    hitEffect.style.left = blockRect.left + blockRect.width/2 + 'px';
                    hitEffect.style.top = blockRect.top + 'px';
                    hitEffect.style.width = '20px';
                    hitEffect.style.height = '20px';
                    hitEffect.style.background = 'radial-gradient(circle, #69f0ae, transparent)';
                    hitEffect.style.borderRadius = '50%';
                    hitEffect.style.zIndex = '15';
                    hitEffect.style.opacity = '0.8';
                    document.body.appendChild(hitEffect);
                    
                    // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞
                    let opacity = 0.8;
                    const fadeOut = setInterval(() => {
                        opacity -= 0.1;
                        hitEffect.style.opacity = opacity;
                        if (opacity <= 0) {
                            clearInterval(fadeOut);
                            if (hitEffect.parentNode) document.body.removeChild(hitEffect);
                        }
                    }, 30);
                    
                    // –£–¥–∞–ª—è–µ–º –ª—É—á
                    setTimeout(() => {
                        if (beam.parentNode) document.body.removeChild(beam);
                    }, 300);
                }
            };
            
            requestAnimationFrame(animateBeam);
        }

        // === –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –ò–ì–†–´ ===
        function setLocation(loc) {
            currentLocation = loc;
            const theme = locations[loc];
            if (gameTitle) gameTitle.textContent = theme.name;
            if (header) header.style.borderColor = theme.borderColor;
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω—ã–π —Ñ–æ–Ω
            planetBackground.setPlanet(loc);
            if (levelAnnounce) {
                levelAnnounce.textContent = theme.name;
                levelAnnounce.style.color = theme.color;
                levelAnnounce.style.opacity = "1";
                setTimeout(() => {
                    levelAnnounce.style.opacity = "0";
                }, 2000);
            }
            updateProgressBar();
        }
        function updateCoins() {
            if (coinsDisplay) coinsDisplay.textContent = Math.floor(coins).toLocaleString();
            updateUpgradeButtons();
        }
        function updateHUD() {
            if (coinsDisplay) coinsDisplay.textContent = Math.floor(coins).toLocaleString();
            if (clickPowerDisplay) clickPowerDisplay.textContent = Math.round(clickPower);
            if (critChanceDisplay) critChanceDisplay.textContent = `${(critChance * 100).toFixed(0)}%`;
            if (critMultiplierDisplay) critMultiplierDisplay.textContent = `x${critMultiplier.toFixed(1)}`;
            const helperText = helperActive ? `${Math.ceil(helperTimeLeft / 1000)}—Å` : "‚Äî";
            if (helperTimerDisplay) helperTimerDisplay.textContent = helperText;
        }
        // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–ë–ù–û–í–õ–ï–ù–ò–Ø –ö–ù–û–ü–û–ö –° –ü–†–û–ü–û–†–¶–ò–û–ù–ê–õ–¨–ù–´–ú –†–û–°–¢–û–ú –°–¢–û–ò–ú–û–°–¢–ò
        function updateUpgradeButtons() {
            const clickCost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
            if (upgradeClickBtn) {
                upgradeClickBtn.querySelector('.upgrade-cost').textContent = clickCost.toLocaleString();
                if (coins >= clickCost) {
                    upgradeClickBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeClickBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            const helperCost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
            if (upgradeHelperBtn) {
                upgradeHelperBtn.querySelector('.upgrade-cost').textContent = helperCost.toLocaleString();
                if (coins >= helperCost && !helperActive) {
                    upgradeHelperBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeHelperBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            const critChanceCost = Math.floor(baseCritChanceCost * Math.pow(1.3, Math.floor(critChance * 100)));
            if (upgradeCritChanceBtn) {
                upgradeCritChanceBtn.querySelector('.upgrade-cost').textContent = critChanceCost.toLocaleString();
                if (coins >= critChanceCost) {
                    upgradeCritChanceBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeCritChanceBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            const critMultiplierCost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, Math.floor((critMultiplier - 2) * 5)));
            if (upgradeCritMultBtn) {
                upgradeCritMultBtn.querySelector('.upgrade-cost').textContent = critMultiplierCost.toLocaleString();
                if (coins >= critMultiplierCost) {
                    upgradeCritMultBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeCritMultBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            const helperDmgCost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
            if (upgradeHelperDmgBtn) {
                upgradeHelperDmgBtn.querySelector('.upgrade-cost').textContent = helperDmgCost.toLocaleString();
                if (coins >= helperDmgCost) {
                    upgradeHelperDmgBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeHelperDmgBtn.className = "upgrade-btn btn-unavailable";
                }
            }
        }
        function buyClickPower() {
            const cost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                clickUpgradeLevel += 1;
                clickPower = calculateClickPower();
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(`–°–∏–ª–∞ —É–≤–µ–ª–∏—á–µ–Ω–∞!<br>–¢–µ–ø–µ—Ä—å: ${Math.round(clickPower)}`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function buyHelper() {
            const cost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
            if (coins >= cost && !helperActive) {
                coins -= cost;
                activateHelper();
                updateCoins();
                updateHUD();
                saveGame();
            }
        }
        function buyCritChance() {
            const cost = Math.floor(baseCritChanceCost * Math.pow(1.3, Math.floor(critChance * 100)));
            if (coins >= cost) {
                coins -= cost;
                critChance = Math.min(1.0, critChance + 0.01);
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(`–®–∞–Ω—Å –∫—Ä–∏—Ç–∞ +1%!<br>–¢–µ–ø–µ—Ä—å: ${(critChance * 100).toFixed(0)}%`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function buyCritMultiplier() {
            const cost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, Math.floor((critMultiplier - 2) * 5)));
            if (coins >= cost) {
                coins -= cost;
                critMultiplier += 0.2;
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(`–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞ +0.2x!<br>–¢–µ–ø–µ—Ä—å: x${critMultiplier.toFixed(1)}`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function buyHelperDamage() {
            const cost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                helperUpgradeLevel += 1;
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(`–£—Ä–æ–Ω Bobo +20%!<br>–£—Ä–æ–≤–µ–Ω—å: ${helperUpgradeLevel}`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function updateHelperTimer() {
            if (helperTimerDisplay) {
                if (helperActive) {
                    const seconds = Math.ceil(helperTimeLeft / 1000);
                    helperTimerDisplay.textContent = `${seconds}—Å`;
                } else {
                    helperTimerDisplay.textContent = `‚Äî`;
                }
            }
        }
        function updateCracks(block, health) {
            if (!block) return;
            const existingCrack = block.querySelector('.crack-overlay');
            if (existingCrack) {
                block.removeChild(existingCrack);
            }
            const maxHealth = parseInt(block.dataset.maxHealth);
            const damageRatio = 1 - (health / maxHealth);
            if (damageRatio > 0.7) {
                addCracks(block, 'crack-3');
            } else if (damageRatio > 0.4) {
                addCracks(block, 'crack-2');
            } else if (damageRatio > 0.1) {
                addCracks(block, 'crack-1');
            }
        }
        function addCracks(block, crackLevel) {
            const crackOverlay = document.createElement('div');
            crackOverlay.className = `crack-overlay ${crackLevel}`;
            block.appendChild(crackOverlay);
        }
        function playSound(soundId) {
            const sound = document.getElementById(soundId);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }
        function hitBlock(block, damage) {
            if (!gameActive) return;
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            playSound('clickSound');
            block.style.transform = 'translateX(-50%) scale(0.85)';
            setTimeout(() => {
                block.style.transform = 'translateX(-50%) scale(1)';
            }, 100);
            let finalDamage = Math.round(damage);
            let isCrit = false;
            if (Math.random() < critChance) {
                finalDamage = Math.round(damage * critMultiplier);
                isCrit = true;
            }
            currentBlockHealth -= finalDamage;
            totalDamageDealt += finalDamage;
            gameMetrics.totalClicks++;
            createDamageText(finalDamage, block, isCrit ? '#FFD700' : '#ff4444');
            checkLocationUpgrade();
            if (currentBlockHealth <= 0) {
                destroyBlock(block);
            } else {
                block.textContent = Math.floor(currentBlockHealth);
                updateCracks(block, currentBlockHealth);
            }
        }
        function destroyBlock(block) {
            const now = Date.now();
            if (now - lastDestroyTime < COMBO_TIME_WINDOW) {
                comboCount++;
            } else {
                comboCount = 1;
            }
            lastDestroyTime = now;
            const baseReward = 25 + (locationRequirements[currentLocation].targetAU * 100);
            let reward = Math.floor(baseReward * balanceConfig.rewardMultiplier);
            const randomBonus = balanceConfig.randomBonusRange.min + 
                               Math.random() * (balanceConfig.randomBonusRange.max - balanceConfig.randomBonusRange.min);
            reward = Math.floor(reward * randomBonus);
            let isRare = false;
            let rareType = null;
            for (const type in rareBlocks) {
                if (block.classList.contains(rareBlocks[type].className)) {
                    isRare = true;
                    rareType = type;
                    reward = Math.floor(reward * rareBlocks[type].multiplier);
                    break;
                }
            }
            if (comboCount > 1) {
                const comboBonus = Math.floor(reward * (comboCount * balanceConfig.comboMultiplier));
                reward += comboBonus;
                showComboText(comboCount, comboBonus, block);
                playSound('comboSound');
            }
            coins += reward;
            gameMetrics.blocksDestroyed++;
            updateCoins();
            updateHUD();
            playSound('breakSound');
            showRewardText(reward, block);
            // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ –±–ª–æ–∫–∞
            createExplosion(block);
            if (gameArea.contains(block)) {
                gameArea.removeChild(block);
            }
            currentBlock = null;
            currentBlockHealth = 0;
            setTimeout(() => {
                if (gameActive) {
                    createMovingBlock();
                }
            }, 500);
        }
        function getBlockSize() {
            const baseSize = isMobile ? 80 : 60;
            const locationIndex = Object.keys(locationRequirements).indexOf(currentLocation);
            if (locationIndex < 3) {
                return baseSize * 1.2;
            }
            return baseSize * (1 + locationIndex * 0.15);
        }
        function createMovingBlock() {
            if (currentBlock && gameArea.contains(currentBlock)) {
                gameArea.removeChild(currentBlock);
            }
            const blockHealth = calculateBlockHealth();
            currentBlockHealth = blockHealth;
            const block = document.createElement("div");
            block.className = "moving-block";
            const size = getBlockSize();
            block.style.width = size + "px";
            block.style.height = size + "px";
            block.style.bottom = "0px";
            block.dataset.maxHealth = blockHealth;
            const theme = locations[currentLocation];
            const colorIndex = Math.floor(Math.random() * theme.blockColors.length);
            let isRare = false;
            let rareType = null;
            const potentialRareType = getRareBlockType();
            if (potentialRareType) {
                isRare = true;
                rareType = potentialRareType;
                const rareBlock = rareBlocks[rareType];
                block.classList.add(rareBlock.className);
                currentBlockHealth = Math.floor(currentBlockHealth * rareBlock.healthMultiplier);
                block.innerHTML = `üåü<div style="font-size: 0.35em; margin-top: 1px; line-height: 1.1;">${rareBlock.name}</div>`;
                announceRareBlock(rareBlock.name);
            } else {
                block.style.background = `linear-gradient(135deg, ${theme.blockColors[colorIndex]}, ${theme.blockColors[(colorIndex + 1) % theme.blockColors.length]})`;
                block.style.boxShadow = `0 0 15px ${theme.blockColors[colorIndex]}`;
                block.style.border = `2px solid ${theme.borderColor}`;
                block.textContent = blockHealth;
            }
            const expectedClicks = getExpectedClicks(currentBlockHealth, clickPower);
            block.addEventListener('click', () => hitBlock(block, clickPower));
            block.addEventListener('touchstart', (e) => {
                e.preventDefault();
                hitBlock(block, clickPower);
            }, { passive: false });
            gameArea.appendChild(block);
            currentBlock = block;
            animateBlock(block);
        }
        function animateBlock(block) {
            if (!gameActive) return;
            const speed = getCurrentSpeed();
            let position = parseInt(block.style.bottom) || 0;
            function move() {
                if (!gameActive || currentBlock !== block) return;
                position += speed / 30;
                block.style.bottom = position + "px";
                if (position > window.innerHeight) {
                    gameOver();
                    return;
                }
                requestAnimationFrame(move);
            }
            move();
        }
        function gameOver(customMessage = null) {
            gameActive = false;
            helperActive = false;
            if (helperInterval) clearInterval(helperInterval);
            if (helperElement && helperElement.parentNode) {
                document.body.removeChild(helperElement);
                helperElement = null;
            }
            const sessionTime = Date.now() - gameMetrics.startTime;
            console.log('üéÆ [–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä] –°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞:', {
                session: gameMetrics.sessions,
                duration_sec: Math.round(sessionTime / 1000),
                total_damage: totalDamageDealt,
                current_location: currentLocation,
                total_coins: coins,
                blocks_destroyed: gameMetrics.blocksDestroyed,
                upgrades_bought: gameMetrics.upgradesBought,
                total_clicks: gameMetrics.totalClicks
            });
            localStorage.setItem('gameSessions', gameMetrics.sessions.toString());
            if (currentBlock && gameArea.contains(currentBlock)) {
                gameArea.removeChild(currentBlock);
                currentBlock = null;
            }
            if (finalScoreDisplay) {
                finalScoreDisplay.textContent = `–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: ${Math.floor(totalDamageDealt).toLocaleString()}`;
            }
            if (gameOverScreen) {
                gameOverScreen.style.display = "flex";
            }
            if (customMessage) {
                const h2 = gameOverScreen.querySelector('h2');
                if (h2) h2.textContent = customMessage;
            }
        }
        function shareResult() {
            const shareText = `üéÆ –Ø –Ω–∞–Ω–µ—Å ${Math.floor(totalDamageDealt).toLocaleString()} —É—Ä–æ–Ω–∞ –∏ —Å–æ–±—Ä–∞–ª ${Math.floor(coins)} –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ! üåå
–°–º–æ–∂–µ—à—å –ø–æ–±–∏—Ç—å –º–æ–π —Ä–µ–∫–æ—Ä–¥?`;
            if (navigator.share) {
                navigator.share({
                    title: '–ú–æ–π —Ä–µ–∫–æ—Ä–¥ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ!',
                    text: shareText
                }).then(() => {
                    coins += 50;
                    updateCoins();
                    updateHUD();
                    showTooltip('+50 –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –∑–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ!');
                    setTimeout(hideTooltip, 2000);
                    saveGame();
                });
            } else {
                navigator.clipboard.writeText(shareText).then(() => {
                    alert('–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω! –ü–æ–¥–µ–ª–∏—Å—å —Å –¥—Ä—É–∑—å—è–º–∏!');
                    coins += 50;
                    updateCoins();
                    updateHUD();
                    saveGame();
                });
            }
        }
        function showTooltip(text) {
            if (tooltip) {
                tooltip.innerHTML = text;
                tooltip.style.opacity = "1";
            }
        }
        function hideTooltip() {
            if (tooltip) tooltip.style.opacity = "0";
        }
        // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –°–¢–ê–†–¢–ê –ò–ì–†–´
        function startGame(reset = true) {
            if (reset) {
                // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –Ω–æ–≤–æ–π –∏–≥—Ä—ã
                coins = 0;
                totalDamageDealt = 0;
                currentLocation = 'mercury';
                clickPower = 1;
                clickUpgradeLevel = 0;
                helperUpgradeLevel = 0;
                helperDamageBonus = 0.3;
                critChance = 0.01;
                critMultiplier = 2.0;
                helperActive = false;
                helperTimeLeft = 0;
                // –û—á–∏—â–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –Ω–æ–≤–æ–π –∏–≥—Ä—ã
                localStorage.removeItem('cosmicBlocksSave');
            } else {
                // –ï—Å–ª–∏ –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º, –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Ä–æ–Ω –ø–æ –Ω–æ–≤–æ–π —Ñ–æ—Ä–º—É–ª–µ
                clickPower = calculateClickPower();
            }
            if (helperInterval) {
                clearInterval(helperInterval);
                helperInterval = null;
            }
            if (helperElement && helperElement.parentNode) {
                document.body.removeChild(helperElement);
                helperElement = null;
            }
            gameArea.innerHTML = "";
            if (welcomeScreen) {
                welcomeScreen.style.display = "none";
            }
            if (saveScreen) {
                saveScreen.style.display = "none";
            }
            if (developmentScreen) {
                developmentScreen.style.display = "none";
            }
            if (gameOverScreen) {
                gameOverScreen.style.display = "none";
            }
            gameActive = true;
            comboCount = 0;
            lastDestroyTime = 0;
            gameMetrics.startTime = Date.now();
            gameMetrics.blocksDestroyed = 0;
            gameMetrics.upgradesBought = 0;
            gameMetrics.totalClicks = 0;
            updateCoins();
            updateHUD();
            updateProgressBar();
            updateUpgradeButtons();
            setLocation(currentLocation);
            setTimeout(() => createMovingBlock(), 500);
        }
        function continueGame() {
            if (loadGame()) {
                startGame(false); // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            } else {
                showTooltip("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã!");
                setTimeout(hideTooltip, 2000);
            }
        }
        function showSaveScreen() {
            if (saveScreen) {
                saveScreen.style.display = "flex";
            }
        }
        function restartGame() {
            startGame(true); // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–≥—Ä—É
        }
        function showStartError() {
            showTooltip("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            setTimeout(hideTooltip, 3000);
        }
        // === –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ===
        if (startBtn) {
            startBtn.addEventListener('click', function() {
                try {
                    showSaveScreen();
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            });
            startBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                try {
                    showSaveScreen();
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            }, { passive: false });
        }
        if (continueBtn) {
            continueBtn.addEventListener('click', function() {
                try {
                    const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
                    if (hasSave) {
                        showSaveScreen();
                    } else {
                        showTooltip("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã!");
                        setTimeout(hideTooltip, 2000);
                    }
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            });
            continueBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                try {
                    const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
                    if (hasSave) {
                        showSaveScreen();
                    } else {
                        showTooltip("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã!");
                        setTimeout(hideTooltip, 2000);
                    }
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            }, { passive: false });
        }
        if (loadSaveBtn) {
            loadSaveBtn.addEventListener('click', continueGame);
            loadSaveBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                continueGame();
            }, { passive: false });
        }
        if (newGameBtn) {
            newGameBtn.addEventListener('click', () => startGame(true));
            newGameBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startGame(true);
            }, { passive: false });
        }
        if (cancelSaveBtn) {
            cancelSaveBtn.addEventListener('click', () => {
                if (saveScreen) saveScreen.style.display = "none";
            });
            cancelSaveBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (saveScreen) saveScreen.style.display = "none";
            }, { passive: false });
        }
        if (restartFromDevBtn) {
            restartFromDevBtn.addEventListener('click', restartGame);
            restartFromDevBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                restartGame();
            }, { passive: false });
        }
        function addMobileButtonHandlers(button, handler) {
            if (button) {
                button.addEventListener('click', handler);
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handler();
                }, { passive: false });
            }
        }
        addMobileButtonHandlers(upgradeClickBtn, buyClickPower);
        addMobileButtonHandlers(upgradeHelperBtn, buyHelper);
        addMobileButtonHandlers(upgradeCritChanceBtn, buyCritChance);
        addMobileButtonHandlers(upgradeCritMultBtn, buyCritMultiplier);
        addMobileButtonHandlers(upgradeHelperDmgBtn, buyHelperDamage);
        if (upgradeClickBtn) {
            upgradeClickBtn.addEventListener('mouseenter', () => showTooltip('–°–∏–ª–∞ —É–¥–∞—Ä–∞<br>–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π —Ä–æ—Å—Ç —É—Ä–æ–Ω–∞'));
            upgradeClickBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeHelperBtn) {
            upgradeHelperBtn.addEventListener('mouseenter', () => showTooltip('Bobo<br>–ê–≤—Ç–æ-–∞—Ç–∞–∫–∞ –Ω–∞ 1 –º–∏–Ω—É—Ç—É<br>+30% —É—Ä–æ–Ω–∞'));
            upgradeHelperBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeCritChanceBtn) {
            upgradeCritChanceBtn.addEventListener('mouseenter', () => showTooltip('–®–∞–Ω—Å –∫—Ä–∏—Ç–∞<br>+1% —à–∞–Ω—Å –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞'));
            upgradeCritChanceBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeCritMultBtn) {
            upgradeCritMultBtn.addEventListener('mouseenter', () => showTooltip('–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞<br>+0.2x –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞'));
            upgradeCritMultBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeHelperDmgBtn) {
            upgradeHelperDmgBtn.addEventListener('mouseenter', () => showTooltip('–£—Ä–æ–Ω Bobo<br>+20% —É—Ä–æ–Ω–∞ –∑–∞ –∞–ø–≥—Ä–µ–π–¥'));
            upgradeHelperDmgBtn.addEventListener('mouseleave', hideTooltip);
        }
        addMobileButtonHandlers(restartBtn, restartGame);
        addMobileButtonHandlers(shareBtn, shareResult);
        addMobileButtonHandlers(dailyRewardBtn, checkDailyReward);
        if (saveBtn) {
            saveBtn.addEventListener('click', saveGame);
            saveBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                saveGame();
            }, { passive: false });
        }
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        updateCoins();
        updateHUD();
        updateProgressBar();
        setLocation(currentLocation);
        // –°–ª—É—à–∞—Ç–µ–ª—å —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', function() {
            if (helperElement) {
                moveHelperToRandomPosition();
            }
        });
    });
    // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∂–µ—Å—Ç–æ–≤ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è
    document.addEventListener('touchstart', function(e) {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });
    document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
    }, { passive: false });
    document.addEventListener('gesturechange', function(e) {
        e.preventDefault();
    }, { passive: false });
    document.addEventListener('gestureend', function(e) {
        e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>