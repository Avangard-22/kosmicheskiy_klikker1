<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    * {
      box-sizing: border-box;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    body {
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      background: #000;
      width: 100vw;
      height: 100vh;
    }
    #planetBackgroundCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      text-align: center;
      z-index: 20;
      padding: 8px 50px 8px 0;
      backdrop-filter: blur(6px);
      border-bottom: 1px solid;
      background: rgba(0, 0, 0, 0.5);
    }
    #gameTitle { 
      margin: 0; 
      font-size: clamp(1.1em, 4vw, 1.4em); 
      color: white;
    }

    /* –ï–î–ò–ù–´–ô HUD - –¥–ª—è –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –≤ –æ–¥–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ (—Å–ª–µ–≤–∞ –ø–æ–¥ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º) */
    #hud-container {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    .hud-item {
      font-size: clamp(0.7em, 3vw, 0.8em);
      text-shadow: 0 0 3px;
      color: white;
      white-space: nowrap;
    }
    .hud-item-new {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #coins { color: #FFD54F; }
    #coins-mobile { color: #FFD54F; }
    #clickPowerInfo { color: #4FC3F7; }
    #clickPower-mobile { color: #4FC3F7; }
    #helperTimer { color: #69f0ae; }
    #helperTimer-mobile { color: #69f0ae; }
    #critChanceInfo { color: #FFD700; }
    #critChance-mobile { color: #FFD700; }
    #critMultiplierInfo { color: #FFD700; }
    #critMult-mobile { color: #FFD700; }

    /* –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä */
    #progressContainer {
      position: absolute;
      top: 145px;
      left: 10px;
      width: min(200px, 50vw);
      height: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      overflow: hidden;
      z-index: 25;
    }
    #progressText {
      position: absolute;
      top: 157px;
      left: 10px;
      font-size: clamp(0.6em, 2.5vw, 0.7em);
      color: #a0d2ff;
      text-shadow: 0 0 3px rgba(160,210,255,0.6);
      z-index: 25;
    }

    /* –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
    #saveBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 30;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      color: #4CAF50;
      transition: transform 0.1s;
    }
    #saveBtn:active { transform: scale(0.92); }

    /* –ö–Ω–æ–ø–∫–∏ —É–ª—É—á—à–µ–Ω–∏–π */
    .upgrade-btn {
      position: absolute;
      right: 10px;
      width: clamp(48px, 12vw, 52px);
      height: clamp(48px, 12vw, 52px);
      border: none;
      border-radius: 8px;
      font-size: clamp(1.1em, 4vw, 1.3em);
      cursor: pointer;
      z-index: 30;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      padding: 3px;
      overflow: hidden;
    }
    .upgrade-btn:active { transform: scale(0.92); }
    #upgradeClickBtn { bottom: 75px; }
    #upgradeHelperBtn { bottom: 135px; }
    #upgradeCritChanceBtn { bottom: 195px; }
    #upgradeCritMultBtn { bottom: 255px; }
    #upgradeHelperDmgBtn { bottom: 315px; }
    .upgrade-cost {
      font-size: clamp(0.5em, 2.5vw, 0.55em);
      margin-top: 1px;
      font-weight: bold;
      text-shadow: 0 0 2px rgba(0,0,0,0.8);
    }

    /* –ë–û–ë–û - –•–ï–õ–ü–ï–† */
    .bobohelper {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(circle, #69f0ae, #00e676);
      border-radius: 50%;
      z-index: 12;
      pointer-events: none;
      box-shadow: 0 0 10px #69f0ae;
      animation: helperFloat 2s ease-in-out infinite;
    }
    .bobohelper-timer {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: #69f0ae;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 4px;
      white-space: nowrap;
      font-weight: bold;
    }
    @keyframes helperFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-5px); }
    }

    /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª–∞ */
    .moving-block {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      font-weight: bold;
      font-size: clamp(0.8em, 4vw, 0.9em);
      font-family: 'Orbitron', monospace;
      transition: transform 0.1s;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      overflow: hidden;
      min-width: 60px;
      min-height: 60px;
    }
    #welcomeScreen, #gameOverScreen, #saveScreen, #developmentScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
      text-align: center;
      padding: 15px;
      box-sizing: border-box;
    }
    #welcomeScreen h2 {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-bottom: 15px;
    }
    #welcomeScreen p {
      max-width: 95%;
      text-align: center;
      margin: 8px 0;
      line-height: 1.4;
      font-size: clamp(0.9em, 3.5vw, 1em);
    }
    .btn {
      padding: clamp(10px, 3vw, 12px) clamp(25px, 6vw, 30px);
      margin-top: 15px;
      font-size: clamp(1em, 4vw, 1.1em);
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px;
    }
    #continueBtn {
      background: #2196F3;
      margin-bottom: 10px;
    }
    #continueBtn.save-available {
      background: #4CAF50;
    }
    #continueBtn.no-save {
      background: #f44336;
    }
    #gameOverScreen h2 {
      font-size: clamp(1.6em, 6vw, 2.2em);
      margin-bottom: 15px;
    }
    #finalScore { font-size: clamp(1.1em, 4vw, 1.4em); margin-bottom: 15px; }
    #restartBtn, #shareBtn, #dailyRewardBtn {
      padding: clamp(8px, 2.5vw, 10px) clamp(20px, 5vw, 24px);
      margin: 6px;
      font-size: clamp(0.9em, 3.5vw, 1em);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px;
    }
    #saveScreen {
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      display: none;
    }
    #saveScreen h2 {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-bottom: 20px;
    }
    #saveScreen p {
      max-width: 90%;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    #developmentScreen {
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(15px);
      display: none;
    }
    #developmentScreen h2 {
      font-size: clamp(1.5em, 6vw, 2.2em);
      margin-bottom: 20px;
      color: #ff9800;
    }
    #developmentScreen p {
      max-width: 90%;
      margin-bottom: 20px;
      line-height: 1.5;
      font-size: clamp(1em, 4vw, 1.2em);
    }
    .damage-text {
      font-size: clamp(1em, 4vw, 1.1em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      opacity: 1;
      transition: transform 0.5s, opacity 0.5s;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      max-width: 100px;
      text-align: center;
      font-weight: bold;
      color: #FFFFFF;
      -webkit-text-stroke: 1px #000000;
    }
    .combo-text {
      font-size: clamp(1.4em, 5vw, 1.8em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: comboPop 0.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 150px;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      font-weight: bold;
      color: #FFD700;
      -webkit-text-stroke: 1px #000000;
    }
    .reward-text {
      font-size: clamp(1.1em, 4vw, 1.3em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: rewardFloat 1.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 120px;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      font-weight: bold;
      color: #FFFFFF;
      -webkit-text-stroke: 1px #000000;
    }
    @media (max-height: 500px) and (orientation: landscape) {
      #header {
        padding: 4px 40px 4px 0;
      }
      #hud-container {
        top: 40px;
        left: 8px;
        gap: 2px;
      }
      .upgrade-btn {
        width: 40px;
        height: 40px;
        right: 8px;
      }
      #upgradeClickBtn { bottom: 60px; }
      #upgradeHelperBtn { bottom: 110px; }
      #upgradeCritChanceBtn { bottom: 160px; }
      #upgradeCritMultBtn { bottom: 210px; }
      #upgradeHelperDmgBtn { bottom: 260px; }
      #progressContainer {
        top: 120px;
        left: 8px;
        width: 150px;
        height: 8px;
      }
      #progressText {
        top: 130px;
        left: 8px;
        font-size: 0.6em;
      }
    }
    #progressBar {
      height: 100%;
      background: linear-gradient(90deg, #bb86fc, #4a55e0);
      border-radius: 6px;
      width: 0%;
      transition: width 0.3s ease;
    }
    #gameArea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 5;
    }
    .crack-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image: 
        radial-gradient(circle at 30% 30%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 70% 70%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 50% 20%, transparent 60%, rgba(0,0,0,0.3) 65%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .crack-1 { opacity: 0.3; }
    .crack-2 { opacity: 0.6; }
    .crack-3 { opacity: 0.9; }
    #levelAnnounce {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(1.2em, 5vw, 1.5em);
      font-weight: bold;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      color: white;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    .upgrade-btn.btn-available { 
      background: linear-gradient(135deg, #4CAF50, #388E3C); 
      color: white; 
    }
    .upgrade-btn.btn-unavailable { 
      background: linear-gradient(135deg, #666, #444); 
      color: #ccc; 
      cursor: not-allowed; 
      opacity: 0.7;
    }
    .tooltip {
      position: absolute;
      bottom: 70px;
      right: 15px;
      padding: 5px 8px;
      border-radius: 6px;
      font-size: clamp(0.75em, 3vw, 0.85em);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      z-index: 35;
    }
    #particlesCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 6;
    }
    @keyframes comboPop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes rewardFloat {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }
    .helper-beam {
      position: absolute;
      width: 3px;
      background: linear-gradient(to top, transparent, #69f0ae);
      z-index: 11;
      pointer-events: none;
      animation: beamPulse 0.5s ease-out;
    }
    @keyframes beamPulse {
      0% { height: 0; opacity: 1; }
      100% { height: 100px; opacity: 0; }
    }
    #welcomeScreen { 
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    }
    #gameOverScreen {
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
    }
    #restartBtn { background: #4CAF50; color: white; }
    #shareBtn { background: #00c853; color: white; }
    #dailyRewardBtn { background: #ffeb3b; color: #000; }
    .block-gold {
        background: linear-gradient(135deg, #ffd700, #ff6b00) !important;
        animation: gold-shimmer 3s infinite;
    }
    .block-rainbow {
        background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #8b00ff) !important;
        background-size: 400% 400%;
        animation: rainbow 3s ease infinite;
    }
    .block-crystal {
        background: linear-gradient(45deg, #00ffff, #ffffff, #00ffff) !important;
        box-shadow: 0 0 25px #00ffff, 0 0 10px #ffffff inset !important;
        animation: crystalPulse 2s ease-in-out infinite !important;
    }
    .block-mystery {
        background: linear-gradient(45deg, #9b59b6, #e74c3c, #3498db) !important;
        background-size: 300% 300% !important;
        box-shadow: 0 0 20px rgba(155, 89, 182, 0.7) !important;
        animation: mysteryShift 4s ease-in-out infinite !important;
    }
    .explosion {
      position: absolute;
      pointer-events: none;
      z-index: 15;
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
      transform: translate(-50%, -50%);
      animation: explode 0.6s ease-out forwards;
    }
    @keyframes explode {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
      }
      50% {
        opacity: 0.8;
      }
      100% {
        transform: translate(-50%, -50%) scale(2.5);
        opacity: 0;
      }
    }
    .explosion-particle {
      position: absolute;
      pointer-events: none;
      z-index: 14;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: particleFly 0.8s ease-out forwards;
    }
    @keyframes particleFly {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }
    @media (max-width: 768px) {
      .explosion {
        width: 150px;
        height: 150px;
      }
      @keyframes explode {
        100% {
          transform: translate(-50%, -50%) scale(2);
        }
      }
      .explosion-particle {
        width: 10px;
        height: 10px;
      }
    }
    @keyframes gold-shimmer {
        0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
        50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 107, 0, 0.6) inset; }
        100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
    }
    @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    @keyframes crystalPulse {
        0%, 100% { transform: translateX(-50%) scale(1); }
        50% { transform: translateX(-50%) scale(1.05); }
    }
    @keyframes mysteryShift {
        0%, 100% { background-position: 0% 50%; filter: hue-rotate(0deg); }
        50% { background-position: 100% 50%; filter: hue-rotate(180deg); }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <canvas id="planetBackgroundCanvas"></canvas>
  <div id="header">
    <h2 id="gameTitle">‚òø –ú–µ—Ä–∫—É—Ä–∏–π</h2>
  </div>
  <button id="saveBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–≥—Ä—É">
    <i class="fas fa-save"></i>
  </button>

  <!-- –ï–î–ò–ù–´–ô HUD –î–õ–Ø –í–°–ï–• –£–°–¢–†–û–ô–°–¢–í -->
  <div id="hud-container">
    <div class="hud-item-new coin"><i class="fas fa-gem"></i> <span id="coins">–ö—Ä–∏—Å—Ç–∞–ª–ª—ã: 0</span></div>
    <div class="hud-item-new power"><i class="fas fa-fist-raised"></i> <span id="clickPower">–°–∏–ª–∞: 1</span></div>
    <div class="hud-item-new crit"><i class="fas fa-star"></i> <span id="crit">–ö—Ä–∏—Ç: 1%</span></div>
    <div class="hud-item-new critMult"><span id="critMult">–ú–Ω–æ–∂: x2.0</span></div>
    <div class="hud-item-new helper"><i class="fas fa-robot"></i> <span id="helperTimer">Bobo: ‚Äî</span></div>
  </div>

  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="progressText">–ü—Ä–æ–≥—Ä–µ—Å—Å: 0.00000 / 0.38710 –∞.–µ. (0%)</div>
  <div id="gameArea"></div>
  <div id="levelAnnounce"></div>

  <button id="upgradeClickBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-hammer"></i>
    <div class="upgrade-cost">80</div>
  </button>
  <button id="upgradeHelperBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-robot"></i>
    <div class="upgrade-cost">1500</div>
  </button>
  <button id="upgradeCritChanceBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-dice"></i>
    <div class="upgrade-cost">500</div>
  </button>
  <button id="upgradeCritMultBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-star"></i>
    <div class="upgrade-cost">800</div>
  </button>
  <button id="upgradeHelperDmgBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-bolt"></i>
    <div class="upgrade-cost">1000</div>
  </button>
  <div id="tooltip" class="tooltip"></div>
  <canvas id="particlesCanvas"></canvas>

  <audio id="clickSound" preload="auto"><source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav"></audio>
  <audio id="breakSound" preload="auto"><source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav"></audio>
  <audio id="upgradeSound" preload="auto"><source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav"></audio>
  <audio id="comboSound" preload="auto"><source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav"></audio>
  <audio id="helperSound" preload="auto"><source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav"></audio>

  <div id="welcomeScreen">
    <h2>üöÄ –ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –ö–õ–ò–ö–ï–†</h2>
    <p>–†–∞–∑—Ä—É—à–∞–π—Ç–µ –≤–æ—Å—Ö–æ–¥—è—â–∏–µ –±–ª–æ–∫–∏ –∏ —Å–æ–±–∏—Ä–∞–π—Ç–µ <strong>–∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –ö—Ä–∏—Å—Ç–∞–ª–ª—ã</strong>!</p>
    <p>–ö–∞–∂–¥—ã–π –±–ª–æ–∫ —Ç—Ä–µ–±—É–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–¥–∞—Ä–æ–≤ –¥–ª—è —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è.</p>
    <p><strong>–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:</strong></p>
    <p>üåå <strong>–ê—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã</strong> ‚Äî –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ—Å—å –ø–æ –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ</p>
    <p>ü™ê <strong>9 —Ä–µ–∞–ª—å–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç</strong> ‚Äî –æ—Ç –ú–µ—Ä–∫—É—Ä–∏—è –¥–æ –ü–ª—É—Ç–æ–Ω–∞</p>
    <p>üöÄ <strong>–£–ª—É—á—à–µ–Ω–∏—è</strong> ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Å–∏–ª—É, –∫—Ä–∏—Ç—ã –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –ø–æ–º–æ—â–Ω–∏–∫–∞</p>
    <p>‚ú® <strong>–†–µ–¥–∫–∏–µ –±–ª–æ–∫–∏</strong> ‚Äî –¥–∞—é—Ç –±–æ–Ω—É—Å—ã –∏ –æ–≥—Ä–æ–º–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã!</p>
    <button id="continueBtn" class="btn no-save">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    <button id="startBtn" class="btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  </div>
  <div id="saveScreen">
    <h2>–°–û–•–†–ê–ù–ï–ù–ò–ï –ò–ì–†–´</h2>
    <p>–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é?</p>
    <button id="loadSaveBtn" class="btn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –∏–≥—Ä—É</button>
    <button id="newGameBtn" class="btn">–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É</button>
    <button id="cancelSaveBtn" class="btn" style="background: #666;">–û—Ç–º–µ–Ω–∞</button>
  </div>
  <div id="developmentScreen">
    <h2>üöß –õ–û–ö–ê–¶–ò–Ø –Æ–ü–ò–¢–ï–† –ù–ê–•–û–î–ò–¢–°–Ø –í –†–ê–ó–†–ê–ë–û–¢–ö–ï</h2>
    <p>–í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –≥—Ä–∞–Ω–∏—Ü—ã –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ—Å–º–æ—Å–∞!</p>
    <p>–°–ª–µ–¥—É—é—â–∞—è –ª–æ–∫–∞—Ü–∏—è –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –±—É–¥—É—â–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏.</p>
    <button id="restartFromDevBtn" class="btn">–ù–∞—á–∞—Ç—å –¥–æ–±—ã—á—É –∑–∞–Ω–æ–≤–æ</button>
  </div>
  <div id="gameOverScreen">
    <h2>–î–û–ë–´–ß–ê –ü–†–ï–†–í–ê–ù–ê!</h2>
    <div id="finalScore">–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: 0</div>
    <button id="restartBtn">–ù–æ–≤–∞—è –¥–æ–±—ã—á–∞</button>
    <button id="shareBtn">–ü–æ–¥–µ–ª–∏—Ç—å—Å—è</button>
    <button id="dailyRewardBtn">üéÅ –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞</button>
  </div>

  <script>
    // === –ü–õ–ê–ù–ï–¢–ê–†–ù–´–ô –§–û–ù –° –ü–û–õ–ù–´–ú–ò –§–£–ù–ö–¶–ò–Ø–ú–ò –ì–ï–ù–ï–†–ê–¶–ò–ò –ü–õ–ê–ù–ï–¢ ===
    (function() {
      const canvas = document.getElementById('planetBackgroundCanvas');
      const ctx = canvas.getContext('2d');
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const fixedSettings = {
        speed: 5,
        density: 5,
        size: 5,
        smoothness: 5,
        nebulaIntensity: 3,
        starDensity: 2
      };
      let animationId = null;
      let currentPlanet = 'mercury';
      let time = 0;
      let particles = [], specialElements = [], nebulae = [], stars = [];
      const planetData = {
        mercury: { name: '–ú–µ—Ä–∫—É—Ä–∏–π', colors: ['#8c7b6b', '#a69b8f', '#5a524c', '#ffaa33', '#ffcc66', '#d9b382', '#bf9e75'], background: ['#1a0f0a', '#2c1d14', '#4a3527'], type: 'rocky' },
        venus: { name: '–í–µ–Ω–µ—Ä–∞', colors: ['#e6b87e', '#d4a574', '#ff8844', '#b35900', '#ff9966', '#e68a53', '#cc7a3d'], background: ['#2a1a0f', '#4a2c1a', '#6b3f20'], type: 'cloudy' },
        earth: { name: '–ó–µ–º–ª—è', colors: ['#4a7b9d', '#5d8aa8', '#2e5a78', '#87ceeb', '#a8d5e5', '#6baed6', '#3c8dbc'], background: ['#0a1a2a', '#1a2a3a', '#2a3a4a'], type: 'oceanic' },
        mars: { name: '–ú–∞—Ä—Å', colors: ['#cd5c5c', '#a52a2a', '#8b4513', '#ff6347', '#e2583e', '#c14533', '#a33226'], background: ['#2a0f0a', '#4a1a14', '#6b251e'], type: 'dusty' },
        jupiter: { name: '–Æ–ø–∏—Ç–µ—Ä', colors: ['#d2b48c', '#bc8f8f', '#a0522d', '#ff7f50', '#e67347', '#cc663d', '#b35933'], background: ['#2a1f14', '#4a3728', '#6b4f3c'], type: 'stormy' },
        saturn: { name: '–°–∞—Ç—É—Ä–Ω', colors: ['#f0e68c', '#daa520', '#b8860b', '#ffd700', '#e6c347', '#ccaa3d', '#b39233'], background: ['#2a2414', '#4a3c28', '#6b543c'], type: 'ringed' },
        uranus: { name: '–£—Ä–∞–Ω', colors: ['#afeeee', '#7fffd4', '#40e0d0', '#48d1cc', '#3dc4bf', '#32b7b2', '#27aaa5'], background: ['#0a1a2a', '#1a2a3a', '#2a3a4a'], type: 'icy' },
        neptune: { name: '–ù–µ–ø—Ç—É–Ω', colors: ['#4169e1', '#0000cd', '#191970', '#1e90ff', '#1a7feb', '#166fd7', '#125fc3'], background: ['#0a0a2a', '#1a1a3a', '#2a2a4a'], type: 'windy' },
        pluto: { name: '–ü–ª—É—Ç–æ–Ω', colors: ['#a9a9a9', '#696969', '#808080', '#d3d3d3', '#c0c0c0', '#b0b0b0', '#9e9e9e'], background: ['#1a1a2a', '#2a2a3a', '#3a3a4a'], type: 'dwarf' }
      };

      function setCanvasSize() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        if (isMobile) {
          const pixelRatio = window.devicePixelRatio || 1;
          canvas.width = canvas.offsetWidth * pixelRatio;
          canvas.height = canvas.offsetHeight * pixelRatio;
          ctx.scale(pixelRatio, pixelRatio);
        }
      }

      class Particle {
        constructor(x, y, radius, color, velocity, type) {
          this.x = x; this.y = y; this.radius = radius; this.color = color;
          this.velocity = velocity; this.alpha = 1; this.type = type;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.02;
          this.pulse = Math.random() * Math.PI * 2;
          this.twinkle = Math.random() * Math.PI * 2;
          this.twinkleSpeed = 0.05 + Math.random() * 0.05;
          this.lifetime = 1; this.maxLifetime = 1;
        }
        draw() {
          ctx.save();
          if (this.type === 'star') {
            const twinkleFactor = 0.7 + 0.3 * Math.sin(this.twinkle);
            ctx.globalAlpha = this.alpha * twinkleFactor * this.lifetime;
          } else if (this.type === 'nebula') {
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            gradient.addColorStop(0, this.color + 'aa');
            gradient.addColorStop(1, this.color + '00');
            ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient; ctx.fill();
          } else {
            ctx.globalAlpha = this.alpha * this.lifetime;
            ctx.translate(this.x, this.y);
            if (this.type === 'ring') {
              ctx.rotate(this.rotation);
              ctx.beginPath(); ctx.ellipse(0, 0, this.radius, this.radius/3, 0, 0, Math.PI * 2);
              ctx.fillStyle = this.color; ctx.fill();
            } else if (this.type === 'ice') {
              ctx.rotate(this.rotation);
              ctx.beginPath();
              for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const x = Math.cos(angle) * this.radius;
                const y = Math.sin(angle) * this.radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.closePath(); ctx.fillStyle = this.color; ctx.fill();
            } else if (this.type === 'crystal') {
              ctx.rotate(this.rotation);
              ctx.beginPath();
              ctx.moveTo(0, -this.radius);
              ctx.lineTo(this.radius/2, 0);
              ctx.lineTo(0, this.radius);
              ctx.lineTo(-this.radius/2, 0);
              ctx.closePath(); ctx.fillStyle = this.color; ctx.fill();
            } else {
              const pulseFactor = 0.8 + 0.2 * Math.sin(this.pulse);
              ctx.beginPath(); ctx.arc(0, 0, this.radius * pulseFactor, 0, Math.PI * 2);
              ctx.fillStyle = this.color; ctx.fill();
            }
          }
          ctx.restore();
        }
        update() {
          this.draw();
          if (this.type === 'ice' || this.type === 'crystal') {
            this.lifetime = Math.min(1, this.lifetime + 0.02);
          }
          const smoothFactor = fixedSettings.smoothness / 10;
          this.velocity.x *= (1 - smoothFactor * 0.05);
          this.velocity.y *= (1 - smoothFactor * 0.05);
          this.x += this.velocity.x; this.y += this.velocity.y;
          this.rotation += this.rotationSpeed;
          this.pulse += 0.05; this.twinkle += this.twinkleSpeed;
          if (this.x < -this.radius * 2) this.x = canvas.width + this.radius;
          else if (this.x > canvas.width + this.radius * 2) this.x = -this.radius;
          if (this.y < -this.radius * 2) this.y = canvas.height + this.radius;
          else if (this.y > canvas.height + this.radius * 2) this.y = -this.radius;
        }
      }

      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        const bgColors = planetData[currentPlanet].background;
        gradient.addColorStop(0, bgColors[0]);
        gradient.addColorStop(0.5, bgColors[1]);
        gradient.addColorStop(1, bgColors[2]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const edgeGradient = ctx.createRadialGradient(
          canvas.width / 2, canvas.height / 2, 0,
          canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.8
        );
        edgeGradient.addColorStop(0, 'transparent');
        edgeGradient.addColorStop(1, 'rgba(0,0,0,0.4)');
        ctx.fillStyle = edgeGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function generateStars() {
        const starCount = fixedSettings.starDensity * 50;
        stars = [];
        for (let i = 0; i < starCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 1.5 + 0.5;
          const starColors = ['#ffffff', '#f8f8ff', '#e6e6fa', '#fffacd', '#f0f8ff'];
          const color = starColors[Math.floor(Math.random() * starColors.length)];
          stars.push(new Particle(x, y, radius, color, {x:0,y:0}, 'star'));
        }
      }

      function generateNebulae() {
        const nebulaCount = fixedSettings.nebulaIntensity;
        nebulae = [];
        for (let i = 0; i < nebulaCount; i++) {
          const aspectRatio = canvas.width / canvas.height;
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 200 + (aspectRatio > 1 ? 80 : 120);
          const planetColors = planetData[currentPlanet].colors;
          const color = planetColors[Math.floor(Math.random() * planetColors.length)];
          const velocity = { x: (Math.random() - 0.5) * 0.05, y: (Math.random() - 0.5) * 0.05 };
          nebulae.push(new Particle(x, y, radius, color, velocity, 'nebula'));
        }
      }

      // === –ü–û–õ–ù–´–ï –§–£–ù–ö–¶–ò–ò –ì–ï–ù–ï–†–ê–¶–ò–ò –ü–õ–ê–ù–ï–¢ ===
      function generateMercury() {
        const particleCount = fixedSettings.density * 15;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 1;
          const color = planetData.mercury.colors[Math.floor(Math.random() * planetData.mercury.colors.length)];
          const speedValue = (Math.random() * 0.5 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = { x: Math.cos(angle) * speedValue, y: Math.sin(angle) * speedValue };
          particles.push(new Particle(x, y, radius, color, velocity, 'rock'));
        }
        for (let i = 0; i < 5; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 20 + 10;
          const color = planetData.mercury.colors[3];
          const velocity = { x: 0, y: 0 };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'sun'));
        }
      }

      function generateVenus() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 3 + 5;
          const color = planetData.venus.colors[Math.floor(Math.random() * planetData.venus.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + Math.PI / 2;
          const velocity = { 
            x: Math.cos(angle) * speedValue * (distance / 100), 
            y: Math.sin(angle) * speedValue * (distance / 100) 
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'cloud'));
        }
      }

      function generateEarth() {
        const particleCount = fixedSettings.density * 25;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 2;
          const color = planetData.earth.colors[Math.floor(Math.random() * planetData.earth.colors.length)];
          const speedValue = (Math.random() * 0.5 + 0.2) * fixedSettings.speed / 5;
          const angle = Math.random() > 0.5 ? 
            Math.PI / 2 + (Math.random() - 0.5) * 0.5 : 
            -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
          const velocity = { x: Math.cos(angle) * speedValue, y: Math.sin(angle) * speedValue };
          particles.push(new Particle(x, y, radius, color, velocity, 'water'));
        }
      }

      function generateMars() {
        const particleCount = fixedSettings.density * 30;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size + 1;
          const color = planetData.mars.colors[Math.floor(Math.random() * planetData.mars.colors.length)];
          const speedValue = (Math.random() * 1 + 0.5) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = { x: Math.cos(angle) * speedValue, y: Math.sin(angle) * speedValue };
          particles.push(new Particle(x, y, radius, color, velocity, 'dust'));
        }
      }

      function generateJupiter() {
        const particleCount = fixedSettings.density * 15;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 4 + 10;
          const color = planetData.jupiter.colors[Math.floor(Math.random() * planetData.jupiter.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.1) * fixedSettings.speed / 5;
          const direction = Math.random() > 0.5 ? 1 : -1;
          const velocity = { x: speedValue * direction, y: 0 };
          particles.push(new Particle(x, y, radius, color, velocity, 'storm'));
        }
        const x = canvas.width * 0.7;
        const y = canvas.height * 0.5;
        const radius = 50;
        const color = planetData.jupiter.colors[3];
        const velocity = { x: -0.1 * fixedSettings.speed / 5, y: 0 };
        specialElements.push(new Particle(x, y, radius, color, velocity, 'spot'));
      }

      function generateSaturn() {
        const particleCount = fixedSettings.density * 10;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 100 + Math.random() * 150;
          const x = canvas.width / 2 + Math.cos(angle) * distance;
          const y = canvas.height / 2 + Math.sin(angle) * distance;
          const radius = Math.random() * fixedSettings.size * 2 + 5;
          const color = planetData.saturn.colors[Math.floor(Math.random() * planetData.saturn.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const orbitalAngle = angle + Math.PI / 2;
          const velocity = { 
            x: Math.cos(orbitalAngle) * speedValue, 
            y: Math.sin(orbitalAngle) * speedValue 
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'ring'));
        }
        for (let i = 0; i < fixedSettings.density * 5; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 3 + 5;
          const color = planetData.saturn.colors[Math.floor(Math.random() * planetData.saturn.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = { x: Math.cos(angle) * speedValue, y: Math.sin(angle) * speedValue };
          particles.push(new Particle(x, y, radius, color, velocity, 'cloud'));
        }
      }

      function generateUranus() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 3;
          const color = planetData.uranus.colors[Math.floor(Math.random() * planetData.uranus.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.05) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = { x: Math.cos(angle) * speedValue, y: Math.sin(angle) * speedValue };
          particles.push(new Particle(x, y, radius, color, velocity, 'ice'));
        }
      }

      function generateNeptune() {
        const particleCount = fixedSettings.density * 25;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size + 2;
          const color = planetData.neptune.colors[Math.floor(Math.random() * planetData.neptune.colors.length)];
          const speedValue = (Math.random() * 0.8 + 0.3) * fixedSettings.speed / 5;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + Math.PI / 2;
          const velocity = { 
            x: Math.cos(angle) * speedValue * (1 + distance / 200), 
            y: Math.sin(angle) * speedValue * (1 + distance / 200) 
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'wind'));
        }
        for (let i = 0; i < 3; i++) {
          const x = canvas.width * (0.2 + i * 0.3);
          const y = canvas.height * 0.5;
          const radius = 30 + Math.random() * 20;
          const color = planetData.neptune.colors[2];
          const velocity = { x: 0.2 * fixedSettings.speed / 5, y: 0 };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'spot'));
        }
      }

      function generatePluto() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 1.5 + 2;
          const color = planetData.pluto.colors[Math.floor(Math.random() * planetData.pluto.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = { x: Math.cos(angle) * speedValue, y: Math.sin(angle) * speedValue };
          if (i % 3 === 0) {
            particles.push(new Particle(x, y, radius, color, velocity, 'ice'));
          } else if (i % 3 === 1) {
            particles.push(new Particle(x, y, radius, color, velocity, 'crystal'));
          } else {
            particles.push(new Particle(x, y, radius, color, velocity, 'rock'));
          }
        }
        for (let i = 0; i < 3; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 30 + 20;
          const color = planetData.pluto.colors[3];
          const velocity = { x: (Math.random() - 0.5) * 0.1, y: (Math.random() - 0.5) * 0.1 };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'ice'));
        }
      }

      function animateParticles() {
        drawBackground();
        nebulae.forEach(n => n.update());
        stars.forEach(s => s.update());
        particles.forEach(p => p.update());
        specialElements.forEach(e => e.update());
      }
      
      function animate() {
        time += 0.01;
        animateParticles();
        animationId = requestAnimationFrame(animate);
      }
      
      function generatePlanetBackground() {
        if (animationId) cancelAnimationFrame(animationId);
        particles = []; specialElements = []; nebulae = []; stars = [];
        generateStars(); generateNebulae();
        const genMap = {
          mercury: generateMercury, venus: generateVenus, earth: generateEarth,
          mars: generateMars, jupiter: generateJupiter, saturn: generateSaturn,
          uranus: generateUranus, neptune: generateNeptune, pluto: generatePluto
        };
        genMap[currentPlanet]();
        animate();
      }
      
      function changePlanet(planet) {
        currentPlanet = planet;
        generatePlanetBackground();
      }
      
      function init() {
        setCanvasSize();
        generatePlanetBackground();
        window.addEventListener('resize', setCanvasSize);
      }
      
      window.planetBackground = { init, setPlanet: changePlanet, setCanvasSize };
    })();

    // === –ü–û–õ–ù–ê–Ø –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ===
    document.addEventListener('DOMContentLoaded', function() {
      planetBackground.init();
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      // === –†–ï–ê–õ–¨–ù–´–ï –†–ê–°–°–¢–û–Ø–ù–ò–Ø –ü–õ–ê–ù–ï–¢ –í –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–• –ï–î–ò–ù–ò–¶–ê–• –ò –§–ê–ö–¢–ò–ß–ï–°–ö–ò–ô –†–ê–°–ß–ï–¢ ===
      const astronomicalUnits = {
        mercury: 0.38710, venus: 0.72333, earth: 1.00000, mars: 1.52366,
        jupiter: 5.20336, saturn: 9.53707, uranus: 19.19126, neptune: 30.06896, pluto: 39.48200
      };
      
      // –§–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ 1 –∞.–µ. –≤ –∫–∏–ª–æ–º–µ—Ç—Ä–∞—Ö
      const AU_TO_KM = 149597870.691;
      // –¢–µ–ø–µ—Ä—å 1 –∞.–µ. = 149597870.691 –∫–º –≤–º–µ—Å—Ç–æ 1000000
      const AU_TO_DAMAGE = AU_TO_KM;

      const locationRequirements = {
        mercury: { damageRequired: 0, targetAU: astronomicalUnits.mercury, nextLocation: 'venus' },
        venus: { damageRequired: 0, targetAU: astronomicalUnits.venus, nextLocation: 'earth' },
        earth: { damageRequired: 0, targetAU: astronomicalUnits.earth, nextLocation: 'mars' },
        mars: { damageRequired: 0, targetAU: astronomicalUnits.mars, nextLocation: 'jupiter' },
        jupiter: { damageRequired: 0, targetAU: astronomicalUnits.jupiter, nextLocation: 'saturn' },
        saturn: { damageRequired: 0, targetAU: astronomicalUnits.saturn, nextLocation: 'uranus' },
        uranus: { damageRequired: 0, targetAU: astronomicalUnits.uranus, nextLocation: 'neptune' },
        neptune: { damageRequired: 0, targetAU: astronomicalUnits.neptune, nextLocation: 'pluto' },
        pluto: { damageRequired: 0, targetAU: astronomicalUnits.pluto, nextLocation: null }
      };

      let blockSpeed = isMobile ? 25 : 20;
      function getCurrentSpeed() {
        const baseSpeed = blockSpeed;
        const locationIndex = Object.keys(locationRequirements).indexOf(currentLocation);
        if (locationIndex < 3) {
          return baseSpeed * 0.85;
        }
        return baseSpeed;
      }

      const baseClickUpgradeCost = 80;
      const baseHelperUpgradeCost = 1500;
      const baseCritChanceCost = 500;
      const baseCritMultiplierCost = 800;
      const baseHelperDmgCost = 1000;

      const rareBlocks = {
        GOLD: { name: "–ó–æ–ª–æ—Ç–æ–π", chance: 0.03, multiplier: 8, healthMultiplier: 1.8, effect: "–ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å", className: "block-gold" },
        RAINBOW: { name: "–†–∞–¥—É–∂–Ω—ã–π", chance: 0.02, multiplier: 5, healthMultiplier: 1.5, effect: "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–∏–ª—ã", className: "block-rainbow" },
        CRYSTAL: { name: "–ö—Ä–∏—Å—Ç–∞–ª—å–Ω—ã–π", chance: 0.025, multiplier: 6, healthMultiplier: 1.6, effect: "–í—Ä–µ–º—è –ø–æ–º–æ—â–Ω–∏–∫–∞", className: "block-crystal" },
        MYSTERY: { name: "–ó–∞–≥–∞–¥–æ—á–Ω—ã–π", chance: 0.015, multiplier: 10, healthMultiplier: 2.0, effect: "–°–ª—É—á–∞–π–Ω—ã–π –±–æ–Ω—É—Å", className: "block-mystery" }
      };

      const balanceConfig = {
        baseHealth: 80,
        targetClicks: 70,
        healthRandomRange: { min: 0.8, max: 1.3 },
        damageProgression: {
          baseMultiplier: 1.15,
          diminishingReturns: 0.96,
          maxLevelEffect: 60
        },
        rewardMultiplier: 2.5,
        comboMultiplier: 0.25,
        randomBonusRange: { min: 0.8, max: 1.5 }
      };

      let stars = [], lavaParticles = [], snowflakes = [], bioDots = [];

      let coins = 0;
      let totalDamageDealt = 0;
      let clickPower = 1;
      let clickUpgradeLevel = 0;
      let gameActive = false;
      let currentLocation = 'mercury';
      let currentBlockHealth = 0;
      let currentBlock = null;
      let comboCount = 0;
      let lastDestroyTime = 0;
      const COMBO_TIME_WINDOW = isMobile ? 1500 : 2000;
      let helperActive = false;
      let helperTimeLeft = 0;
      const helperDuration = 60000;
      let helperInterval;
      let helperUpgradeLevel = 0;
      const helperUpgradeMultiplier = 1.8;
      let critChance = 0.01;
      let critMultiplier = 2.0;
      let helperDamageBonus = 0.3;
      let helperPosition = { x: 0, y: 0 };
      let helperElement = null;

      const gameMetrics = {
        startTime: Date.now(),
        blocksDestroyed: 0,
        upgradesBought: 0,
        totalClicks: 0,
        sessions: parseInt(localStorage.getItem('gameSessions') || '0') + 1
      };

      const locations = {
        mercury: { name: "‚òø –ú–µ—Ä–∫—É—Ä–∏–π", color: "#bb86fc", coinColor: "#a0d2ff", borderColor: "#4a55e0", blockColors: ['#2962ff', '#4fc3f7', '#bb86fc', '#f8bbd0'] },
        venus: { name: "‚ôÄ –í–µ–Ω–µ—Ä–∞", color: "#ffab91", coinColor: "#a0d2ff", borderColor: "#ff5722", blockColors: ['#ff5722', '#ff9800', '#ff5722', '#e91e63'] },
        earth: { name: "‚ôÅ –ó–µ–º–ª—è", color: "#80deea", coinColor: "#a0d2ff", borderColor: "#0288d1", blockColors: ['#0288d1', '#29b6f6', '#00bcd4', '#00e5ff'] },
        mars: { name: "‚ôÇ –ú–∞—Ä—Å", color: "#a5d6a7", coinColor: "#a0d2ff", borderColor: "#388e3c", blockColors: ['#388e3c', '#66bb6a', '#9ccc65', '#d4e157'] },
        jupiter: { name: "‚ôÉ –Æ–ø–∏—Ç–µ—Ä", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
        saturn: { name: "‚ôÑ –°–∞—Ç—É—Ä–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
        uranus: { name: "‚ôÖ –£—Ä–∞–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
        neptune: { name: "‚ôÜ –ù–µ–ø—Ç—É–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
        pluto: { name: "‚ôá –ü–ª—É—Ç–æ–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] }
      };

      function updateHUD() {
        const coinText = Math.floor(coins).toLocaleString();
        document.getElementById('coins').textContent = `–ö—Ä–∏—Å—Ç–∞–ª–ª—ã: ${coinText}`;
        
        document.getElementById('clickPower').textContent = `–°–∏–ª–∞: ${Math.round(clickPower)}`;
        
        document.getElementById('crit').textContent = `–ö—Ä–∏—Ç: ${(critChance * 100).toFixed(0)}%`;
        document.getElementById('critMult').textContent = `–ú–Ω–æ–∂: x${critMultiplier.toFixed(1)}`;
        
        const helperText = helperActive ? `${Math.ceil(helperTimeLeft / 1000)}—Å` : "‚Äî";
        document.getElementById('helperTimer').textContent = `Bobo: ${helperText}`;
      }

      function calculateBlockHealth() {
        const location = locationRequirements[currentLocation];
        const locationBonus = 1 + (location.targetAU * 2);
        let baseHealth = balanceConfig.baseHealth * locationBonus;
        const targetHealth = clickPower * balanceConfig.targetClicks;
        const combinedHealth = (baseHealth + targetHealth) / 2;
        const randomFactor = balanceConfig.healthRandomRange.min + 
                            Math.random() * (balanceConfig.healthRandomRange.max - balanceConfig.healthRandomRange.min);
        return Math.floor(combinedHealth * randomFactor);
      }

      function calculateClickPower() {
        const basePower = 1;
        const upgradeBonus = clickUpgradeLevel;
        const diminishingEffect = Math.pow(balanceConfig.damageProgression.diminishingReturns, 
                                         Math.min(clickUpgradeLevel, balanceConfig.damageProgression.maxLevelEffect));
        const nonLinearGrowth = Math.sqrt(clickUpgradeLevel + 1);
        return basePower + (upgradeBonus * diminishingEffect * nonLinearGrowth * balanceConfig.damageProgression.baseMultiplier);
      }

      function getExpectedClicks(blockHealth, playerDamage) {
        return Math.ceil(blockHealth / playerDamage);
      }

      function getRareBlockType() {
        const rand = Math.random();
        let cumulativeChance = 0;
        for (const [type, block] of Object.entries(rareBlocks)) {
          cumulativeChance += block.chance;
          if (rand <= cumulativeChance) {
            return type;
          }
        }
        return null;
      }

      function announceRareBlock(blockName) {
        const announce = document.createElement('div');
        announce.className = 'rare-block-announce';
        announce.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 1.8em;
          font-weight: bold;
          color: gold;
          z-index: 50;
          text-shadow: 0 0 10px black;
          animation: fadeInOut 2s;
        `;
        announce.textContent = `üåü ${blockName} –±–ª–æ–∫! üåü`;
        document.body.appendChild(announce);
        setTimeout(() => {
          if (announce.parentNode) {
            document.body.removeChild(announce);
          }
        }, 2000);
      }

      // === –£–õ–£–ß–®–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –°–û–•–†–ê–ù–ï–ù–ò–Ø ===
      function saveGame() {
        const saveData = {
          coins,
          clickPower,
          clickUpgradeLevel,
          critChance,
          critMultiplier,
          helperDamageBonus,
          helperUpgradeLevel,
          totalDamageDealt,
          currentLocation,
          lastDailyReward: localStorage.getItem('lastDailyReward'),
          gameActive: true,
          timestamp: Date.now()
        };
        localStorage.setItem('cosmicBlocksSave', JSON.stringify(saveData));
        showTooltip('–ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!');
        setTimeout(hideTooltip, 1500);
        updateContinueButton();
      }

      function loadGame() {
        const saved = localStorage.getItem('cosmicBlocksSave');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            const saveAge = Date.now() - (data.timestamp || 0);
            const maxSaveAge = 30 * 24 * 60 * 60 * 1000;
            if (saveAge < maxSaveAge) {
              coins = data.coins || 0;
              clickPower = data.clickPower || 1;
              clickUpgradeLevel = data.clickUpgradeLevel || 0;
              critChance = data.critChance || 0.01;
              critMultiplier = data.critMultiplier || 2.0;
              helperDamageBonus = data.helperDamageBonus || 0.3;
              helperUpgradeLevel = data.helperUpgradeLevel || 0;
              totalDamageDealt = data.totalDamageDealt || 0;
              currentLocation = data.currentLocation || 'mercury';
              return true;
            } else {
              localStorage.removeItem('cosmicBlocksSave');
            }
          } catch (e) {
            console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', e);
          }
        }
        return false;
      }

      function updateContinueButton() {
        const continueBtn = document.getElementById('continueBtn');
        if (continueBtn) {
          const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
          if (hasSave) {
            continueBtn.className = 'btn save-available';
            continueBtn.textContent = '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å';
          } else {
            continueBtn.className = 'btn no-save';
            continueBtn.textContent = '–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è';
          }
        }
      }

      function checkDailyReward() {
        const now = Date.now();
        const last = localStorage.getItem('lastDailyReward');
        if (!last || now - parseInt(last) >= 24 * 60 * 60 * 1000) {
          coins += 1000;
          updateHUD();
          localStorage.setItem('lastDailyReward', now.toString());
          showTooltip('üéÅ +1000 –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤!');
          setTimeout(hideTooltip, 2000);
          saveGame();
          return true;
        } else {
          const hoursLeft = Math.ceil((24 * 60 * 60 * 1000 - (now - parseInt(last))) / (1000 * 60 * 60));
          showTooltip(`–ù–∞–≥—Ä–∞–¥–∞ —á–µ—Ä–µ–∑ ${hoursLeft} —á.`);
          setTimeout(hideTooltip, 2000);
          return false;
        }
      }

      // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã DOM
      const DOMElements = {
        coinsDisplay: document.getElementById("coins"),
        clickPowerDisplay: document.getElementById("clickPower"),
        helperTimerDisplay: document.getElementById("helperTimer"),
        critDisplay: document.getElementById("crit"),
        critMultDisplay: document.getElementById("critMult"),
        progressBar: document.getElementById("progressBar"),
        progressText: document.getElementById("progressText"),
        levelAnnounce: document.getElementById("levelAnnounce"),
        gameTitle: document.getElementById("gameTitle"),
        upgradeClickBtn: document.getElementById("upgradeClickBtn"),
        upgradeHelperBtn: document.getElementById("upgradeHelperBtn"),
        upgradeCritChanceBtn: document.getElementById("upgradeCritChanceBtn"),
        upgradeCritMultBtn: document.getElementById("upgradeCritMultBtn"),
        upgradeHelperDmgBtn: document.getElementById("upgradeHelperDmgBtn"),
        gameOverScreen: document.getElementById("gameOverScreen"),
        developmentScreen: document.getElementById("developmentScreen"),
        finalScoreDisplay: document.getElementById("finalScore"),
        tooltip: document.getElementById("tooltip"),
        welcomeScreen: document.getElementById("welcomeScreen"),
        saveScreen: document.getElementById("saveScreen"),
        header: document.getElementById("header"),
        gameArea: document.getElementById("gameArea"),
        particlesCanvas: document.getElementById("particlesCanvas"),
        startBtn: document.getElementById("startBtn"),
        continueBtn: document.getElementById("continueBtn"),
        loadSaveBtn: document.getElementById("loadSaveBtn"),
        newGameBtn: document.getElementById("newGameBtn"),
        cancelSaveBtn: document.getElementById("cancelSaveBtn"),
        restartBtn: document.getElementById("restartBtn"),
        restartFromDevBtn: document.getElementById("restartFromDevBtn"),
        shareBtn: document.getElementById("shareBtn"),
        dailyRewardBtn: document.getElementById("dailyRewardBtn"),
        saveBtn: document.getElementById("saveBtn")
      };

      let missingElements = [];
      Object.entries(DOMElements).forEach(([name, element]) => {
        if (!element) missingElements.push(name);
      });
      if (missingElements.length > 0) {
        console.error("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —ç–ª–µ–º–µ–Ω—Ç—ã:", missingElements.join(", "));
        return;
      }

      const {
        coinsDisplay, clickPowerDisplay, helperTimerDisplay, critDisplay, critMultDisplay, 
        progressBar, progressText, levelAnnounce, gameTitle, upgradeClickBtn, 
        upgradeHelperBtn, upgradeCritChanceBtn, upgradeCritMultBtn, upgradeHelperDmgBtn, 
        gameOverScreen, developmentScreen, finalScoreDisplay, tooltip, welcomeScreen, 
        saveScreen, header, gameArea, particlesCanvas, startBtn, continueBtn, 
        loadSaveBtn, newGameBtn, cancelSaveBtn, restartBtn, restartFromDevBtn, 
        shareBtn, dailyRewardBtn, saveBtn
      } = DOMElements;

      function createExplosion(block) {
        const rect = block.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const explosionSize = isMobile ? 150 : 200;
        const explosion = document.createElement('div');
        explosion.className = 'explosion';
        explosion.style.left = centerX + 'px';
        explosion.style.top = centerY + 'px';
        explosion.style.width = explosionSize + 'px';
        explosion.style.height = explosionSize + 'px';
        document.body.appendChild(explosion);
        const particleCount = isMobile ? 20 : 25;
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'explosion-particle';
          particle.style.left = centerX + 'px';
          particle.style.top = centerY + 'px';
          const particleSize = isMobile ? 10 : 12;
          particle.style.width = particleSize + 'px';
          particle.style.height = particleSize + 'px';
          const theme = locations[currentLocation];
          particle.style.backgroundColor = theme.blockColors[Math.floor(Math.random() * theme.blockColors.length)];
          const angle = Math.random() * Math.PI * 2;
          const distance = 50 + Math.random() * 100;
          particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
          particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');
          document.body.appendChild(particle);
          setTimeout(() => {
            if (particle.parentNode) {
              document.body.removeChild(particle);
            }
          }, 800);
        }
        setTimeout(() => {
          if (explosion.parentNode) {
            document.body.removeChild(explosion);
          }
        }, 600);
      }

      function updateProgressBar() {
        const currentReq = locationRequirements[currentLocation];
        const nextLocation = currentReq.nextLocation;
        const currentAU = totalDamageDealt / AU_TO_DAMAGE;
        const targetAU = currentReq.targetAU;
        const percentage = Math.min(100, (currentAU / targetAU) * 100);
        progressBar.style.width = percentage + '%';
        progressText.textContent = `–ü—Ä–æ–≥—Ä–µ—Å—Å: ${currentAU.toFixed(5)} / ${targetAU.toFixed(5)} –∞.–µ. (${percentage.toFixed(1)}%)`;
      }

      function checkLocationUpgrade() {
        const currentReq = locationRequirements[currentLocation];
        const nextLocation = currentReq.nextLocation;
        const currentAU = totalDamageDealt / AU_TO_DAMAGE;
        const targetAU = currentReq.targetAU;
        if (nextLocation && currentAU >= targetAU) {
          if (nextLocation === 'jupiter') {
            showDevelopmentScreen();
            return;
          }
          setLocation(nextLocation);
          showTooltip(`–û—Ç–∫—Ä—ã—Ç–∞ –ª–æ–∫–∞—Ü–∏—è: ${locations[nextLocation].name}!`);
          setTimeout(hideTooltip, 3000);
        }
        updateProgressBar();
      }

      function showDevelopmentScreen() {
        if (developmentScreen) {
          developmentScreen.style.display = "flex";
          gameActive = false;
        }
      }

      function createDamageText(damage, block, color = '#ff4444') {
        const rect = block.getBoundingClientRect();
        const text = document.createElement('div');
        text.className = 'damage-text';
        text.textContent = `-${damage}`;
        text.style.color = color;
        let left = rect.left + rect.width / 2;
        let top = rect.top;
        const textWidth = 100;
        if (left < textWidth / 2) left = textWidth / 2;
        if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
        if (top < 50) top = 50;
        text.style.left = left + 'px';
        text.style.top = top + 'px';
        document.body.appendChild(text);
        let opacity = 1;
        let yPos = parseInt(text.style.top);
        function animate() {
          opacity -= 0.02;
          yPos -= 2;
          text.style.opacity = opacity;
          text.style.top = yPos + 'px';
          if (opacity > 0) {
            requestAnimationFrame(animate);
          } else {
            if (text.parentNode) {
              document.body.removeChild(text);
            }
          }
        }
        animate();
      }

      function showComboText(combo, bonus, block) {
        const rect = block.getBoundingClientRect();
        const text = document.createElement('div');
        text.className = 'combo-text';
        text.textContent = `–ö–æ–º–±–æ x${combo}! +${bonus}`;
        let left = rect.left + rect.width / 2;
        let top = rect.top;
        const textWidth = 150;
        if (left < textWidth / 2) left = textWidth / 2;
        if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
        if (top < 50) top = 50;
        text.style.left = left + 'px';
        text.style.top = top + 'px';
        document.body.appendChild(text);
        setTimeout(() => {
          if (text.parentNode) {
            document.body.removeChild(text);
          }
        }, 1000);
      }

      function showRewardText(reward, block) {
        const rect = block.getBoundingClientRect();
        const text = document.createElement('div');
        text.className = 'reward-text';
        text.textContent = `+${reward} üíé`;
        let left = rect.left + rect.width / 2;
        let top = rect.top + rect.height / 2;
        const textWidth = 120;
        if (left < textWidth / 2) left = textWidth / 2;
        if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
        if (top < 50) top = 50;
        text.style.left = left + 'px';
        text.style.top = top + 'px';
        document.body.appendChild(text);
        setTimeout(() => {
          if (text.parentNode) {
            document.body.removeChild(text);
          }
        }, 1500);
      }

      function moveHelperToRandomPosition() {
        if (!helperElement) return;
        
        let blockRect = { left: window.innerWidth/2, top: window.innerHeight/2 };
        if (currentBlock) {
          blockRect = currentBlock.getBoundingClientRect();
        }
        
        let attempts = 0;
        let validPosition = false;
        const safeDistance = 150;
        
        while (!validPosition && attempts < 20) {
          attempts++;
          
          const randomX = Math.random() * (window.innerWidth - 60) + 30;
          const randomY = Math.random() * (window.innerHeight - 120) + 60;
          
          const distance = Math.sqrt(
            Math.pow(randomX - (blockRect.left + blockRect.width/2), 2) + 
            Math.pow(randomY - (blockRect.top + blockRect.height/2), 2)
          );
          
          const safeFromEdges = randomX > 60 && randomX < window.innerWidth - 60 && 
                              randomY > 100 && randomY < window.innerHeight - 60;
          
          if (distance > safeDistance && safeFromEdges) {
            helperPosition = { x: randomX, y: randomY };
            validPosition = true;
          }
        }
        
        if (!validPosition) {
          helperPosition = {
            x: window.innerWidth * 0.7,
            y: window.innerHeight * 0.7
          };
        }
        
        helperElement.style.left = helperPosition.x + 'px';
        helperElement.style.top = helperPosition.y + 'px';
      }

      function createHelperElement() {
        if (helperElement && helperElement.parentNode) {
          document.body.removeChild(helperElement);
        }
        
        helperElement = document.createElement('div');
        helperElement.className = 'bobohelper';
        
        const timerElement = document.createElement('div');
        timerElement.className = 'bobohelper-timer';
        timerElement.textContent = `${Math.ceil(helperTimeLeft / 1000)}—Å`;
        helperElement.appendChild(timerElement);
        
        document.body.appendChild(helperElement);
        moveHelperToRandomPosition();
        
        helperElement.style.opacity = '0';
        setTimeout(() => {
          if (helperElement) helperElement.style.opacity = '1';
        }, 100);
        
        const timerInterval = setInterval(() => {
          if (!helperActive || !helperElement) {
            clearInterval(timerInterval);
            return;
          }
          
          const timerText = helperElement.querySelector('.bobohelper-timer');
          if (timerText) {
            timerText.textContent = `${Math.ceil(helperTimeLeft / 1000)}—Å`;
          }
        }, 1000);
        
        return timerInterval;
      }

      function activateHelper() {
        if (helperActive) return;
        helperActive = true;
        helperTimeLeft = helperDuration;
        
        const timerInterval = createHelperElement();
        
        helperInterval = setInterval(() => {
          if (helperActive && currentBlock && gameActive) {
            helperAttack();
          }
        }, 1500);
        
        const helperTimer = setInterval(() => {
          if (!helperActive) {
            clearInterval(helperTimer);
            if (timerInterval) clearInterval(timerInterval);
            return;
          }
          helperTimeLeft -= 1000;
          if (helperTimeLeft <= 0) {
            helperActive = false;
            clearInterval(helperInterval);
            clearInterval(helperTimer);
            if (timerInterval) clearInterval(timerInterval);
            
            if (helperElement) {
              helperElement.style.opacity = '0';
              setTimeout(() => {
                if (helperElement && helperElement.parentNode) {
                  document.body.removeChild(helperElement);
                  helperElement = null;
                }
              }, 300);
            }
            
            updateUpgradeButtons();
            showTooltip('Bobo –∑–∞–∫–æ–Ω—á–∏–ª —Ä–∞–±–æ—Ç—É!');
            setTimeout(hideTooltip, 1500);
          }
        }, 1000);
        
        updateUpgradeButtons();
        showTooltip('Bobo –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 1 –º–∏–Ω—É—Ç—É!');
        setTimeout(hideTooltip, 1500);
      }

      function helperAttack() {
        if (!currentBlock || !helperActive || !helperElement) return;
        
        createHelperEffect();
        
        const baseHelperDmg = clickPower * (1 + helperDamageBonus);
        const upgradedHelperDmg = baseHelperDmg * (1 + helperUpgradeLevel * 0.2);
        currentBlockHealth -= upgradedHelperDmg;
        totalDamageDealt += upgradedHelperDmg;
        gameMetrics.totalClicks++;
        
        createDamageText(Math.round(upgradedHelperDmg), currentBlock, '#69f0ae');
        checkLocationUpgrade();
        
        if (currentBlockHealth <= 0) {
          destroyBlock(currentBlock);
        } else {
          currentBlock.textContent = Math.floor(currentBlockHealth);
          updateCracks(currentBlock, currentBlockHealth);
        }
      }

      function createHelperEffect() {
        if (!currentBlock || !helperElement) return;
        
        const blockRect = currentBlock.getBoundingClientRect();
        const helperRect = helperElement.getBoundingClientRect();
        
        const beam = document.createElement('div');
        beam.className = 'helper-beam';
        beam.style.left = helperRect.left + 15 + 'px';
        beam.style.top = helperRect.top + 30 + 'px';
        beam.style.width = '2px';
        beam.style.height = '0';
        
        document.body.appendChild(beam);
        
        const animateBeam = () => {
          const currentHeight = parseInt(beam.style.height) || 0;
          const targetHeight = blockRect.top - (helperRect.top + 30);
          
          if (currentHeight < targetHeight) {
            beam.style.height = (currentHeight + 5) + 'px';
            requestAnimationFrame(animateBeam);
          } else {
            const hitEffect = document.createElement('div');
            hitEffect.style.position = 'absolute';
            hitEffect.style.left = blockRect.left + blockRect.width/2 + 'px';
            hitEffect.style.top = blockRect.top + 'px';
            hitEffect.style.width = '20px';
            hitEffect.style.height = '20px';
            hitEffect.style.background = 'radial-gradient(circle, #69f0ae, transparent)';
            hitEffect.style.borderRadius = '50%';
            hitEffect.style.zIndex = '15';
            hitEffect.style.opacity = '0.8';
            document.body.appendChild(hitEffect);
            
            let opacity = 0.8;
            const fadeOut = setInterval(() => {
              opacity -= 0.1;
              hitEffect.style.opacity = opacity;
              if (opacity <= 0) {
                clearInterval(fadeOut);
                if (hitEffect.parentNode) document.body.removeChild(hitEffect);
              }
            }, 30);
            
            setTimeout(() => {
              if (beam.parentNode) document.body.removeChild(beam);
            }, 300);
          }
        };
        
        requestAnimationFrame(animateBeam);
      }

      function setLocation(loc) {
        currentLocation = loc;
        const theme = locations[loc];
        gameTitle.textContent = theme.name;
        header.style.borderColor = theme.borderColor;
        planetBackground.setPlanet(loc);
        levelAnnounce.textContent = theme.name;
        levelAnnounce.style.color = theme.color;
        levelAnnounce.style.opacity = "1";
        setTimeout(() => {
          levelAnnounce.style.opacity = "0";
        }, 2000);
        updateProgressBar();
      }

      function updateCoins() {
        updateHUD();
        updateUpgradeButtons();
      }

      function updateUpgradeButtons() {
        const clickCost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
        if (upgradeClickBtn) {
          upgradeClickBtn.querySelector('.upgrade-cost').textContent = clickCost.toLocaleString();
          if (coins >= clickCost) {
            upgradeClickBtn.className = "upgrade-btn btn-available";
          } else {
            upgradeClickBtn.className = "upgrade-btn btn-unavailable";
          }
        }
        const helperCost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
        if (upgradeHelperBtn) {
          upgradeHelperBtn.querySelector('.upgrade-cost').textContent = helperCost.toLocaleString();
          if (coins >= helperCost && !helperActive) {
            upgradeHelperBtn.className = "upgrade-btn btn-available";
          } else {
            upgradeHelperBtn.className = "upgrade-btn btn-unavailable";
          }
        }
        const critChanceCost = Math.floor(baseCritChanceCost * Math.pow(1.3, Math.floor(critChance * 100)));
        if (upgradeCritChanceBtn) {
          upgradeCritChanceBtn.querySelector('.upgrade-cost').textContent = critChanceCost.toLocaleString();
          if (coins >= critChanceCost) {
            upgradeCritChanceBtn.className = "upgrade-btn btn-available";
          } else {
            upgradeCritChanceBtn.className = "upgrade-btn btn-unavailable";
          }
        }
        const critMultiplierCost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, Math.floor((critMultiplier - 2) * 5)));
        if (upgradeCritMultBtn) {
          upgradeCritMultBtn.querySelector('.upgrade-cost').textContent = critMultiplierCost.toLocaleString();
          if (coins >= critMultiplierCost) {
            upgradeCritMultBtn.className = "upgrade-btn btn-available";
          } else {
            upgradeCritMultBtn.className = "upgrade-btn btn-unavailable";
          }
        }
        const helperDmgCost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
        if (upgradeHelperDmgBtn) {
          upgradeHelperDmgBtn.querySelector('.upgrade-cost').textContent = helperDmgCost.toLocaleString();
          if (coins >= helperDmgCost) {
            upgradeHelperDmgBtn.className = "upgrade-btn btn-available";
          } else {
            upgradeHelperDmgBtn.className = "upgrade-btn btn-unavailable";
          }
        }
      }

      function buyClickPower() {
        const cost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
        if (coins >= cost) {
          coins -= cost;
          clickUpgradeLevel += 1;
          clickPower = calculateClickPower();
          gameMetrics.upgradesBought++;
          updateCoins();
          playSound('upgradeSound');
          showTooltip(`–°–∏–ª–∞ —É–≤–µ–ª–∏—á–µ–Ω–∞!<br>–¢–µ–ø–µ—Ä—å: ${Math.round(clickPower)}`);
          setTimeout(hideTooltip, 1500);
          saveGame();
        }
      }

      function buyHelper() {
        const cost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
        if (coins >= cost && !helperActive) {
          coins -= cost;
          activateHelper();
          updateCoins();
          saveGame();
        }
      }

      function buyCritChance() {
        const cost = Math.floor(baseCritChanceCost * Math.pow(1.3, Math.floor(critChance * 100)));
        if (coins >= cost) {
          coins -= cost;
          critChance = Math.min(1.0, critChance + 0.01);
          gameMetrics.upgradesBought++;
          updateCoins();
          playSound('upgradeSound');
          showTooltip(`–®–∞–Ω—Å –∫—Ä–∏—Ç–∞ +1%!<br>–¢–µ–ø–µ—Ä—å: ${(critChance * 100).toFixed(0)}%`);
          setTimeout(hideTooltip, 1500);
          saveGame();
        }
      }

      function buyCritMultiplier() {
        const cost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, Math.floor((critMultiplier - 2) * 5)));
        if (coins >= cost) {
          coins -= cost;
          critMultiplier += 0.2;
          gameMetrics.upgradesBought++;
          updateCoins();
          playSound('upgradeSound');
          showTooltip(`–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞ +0.2x!<br>–¢–µ–ø–µ—Ä—å: x${critMultiplier.toFixed(1)}`);
          setTimeout(hideTooltip, 1500);
          saveGame();
        }
      }

      function buyHelperDamage() {
        const cost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
        if (coins >= cost) {
          coins -= cost;
          helperUpgradeLevel += 1;
          gameMetrics.upgradesBought++;
          updateCoins();
          playSound('upgradeSound');
          showTooltip(`–£—Ä–æ–Ω Bobo +20%!<br>–£—Ä–æ–≤–µ–Ω—å: ${helperUpgradeLevel}`);
          setTimeout(hideTooltip, 1500);
          saveGame();
        }
      }

      function updateHelperTimer() {
        if (helperElement) {
          const timerText = helperElement.querySelector('.bobohelper-timer');
          if (timerText) {
            timerText.textContent = `${Math.ceil(helperTimeLeft / 1000)}—Å`;
          }
        }
      }

      function updateCracks(block, health) {
        if (!block) return;
        const existingCrack = block.querySelector('.crack-overlay');
        if (existingCrack) {
          block.removeChild(existingCrack);
        }
        const maxHealth = parseInt(block.dataset.maxHealth);
        const damageRatio = 1 - (health / maxHealth);
        if (damageRatio > 0.7) {
          addCracks(block, 'crack-3');
        } else if (damageRatio > 0.4) {
          addCracks(block, 'crack-2');
        } else if (damageRatio > 0.1) {
          addCracks(block, 'crack-1');
        }
      }

      function addCracks(block, crackLevel) {
        const crackOverlay = document.createElement('div');
        crackOverlay.className = `crack-overlay ${crackLevel}`;
        block.appendChild(crackOverlay);
      }

      function playSound(soundId) {
        const sound = document.getElementById(soundId);
        if (sound) {
          sound.currentTime = 0;
          sound.play().catch(e => {});
        }
      }

      function hitBlock(block, damage) {
        if (!gameActive) return;
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
        playSound('clickSound');
        block.style.transform = 'translateX(-50%) scale(0.85)';
        setTimeout(() => {
          block.style.transform = 'translateX(-50%) scale(1)';
        }, 100);
        let finalDamage = Math.round(damage);
        let isCrit = false;
        if (Math.random() < critChance) {
          finalDamage = Math.round(damage * critMultiplier);
          isCrit = true;
        }
        currentBlockHealth -= finalDamage;
        totalDamageDealt += finalDamage;
        gameMetrics.totalClicks++;
        createDamageText(finalDamage, block, isCrit ? '#FFD700' : '#ff4444');
        checkLocationUpgrade();
        if (currentBlockHealth <= 0) {
          destroyBlock(block);
        } else {
          block.textContent = Math.floor(currentBlockHealth);
          updateCracks(block, currentBlockHealth);
        }
      }

      function destroyBlock(block) {
        const now = Date.now();
        if (now - lastDestroyTime < COMBO_TIME_WINDOW) {
          comboCount++;
        } else {
          comboCount = 1;
        }
        lastDestroyTime = now;
        const baseReward = 25 + (locationRequirements[currentLocation].targetAU * 100);
        let reward = Math.floor(baseReward * balanceConfig.rewardMultiplier);
        const randomBonus = balanceConfig.randomBonusRange.min + 
                           Math.random() * (balanceConfig.randomBonusRange.max - balanceConfig.randomBonusRange.min);
        reward = Math.floor(reward * randomBonus);
        let isRare = false;
        let rareType = null;
        for (const type in rareBlocks) {
          if (block.classList.contains(rareBlocks[type].className)) {
            isRare = true;
            rareType = type;
            reward = Math.floor(reward * rareBlocks[type].multiplier);
            break;
          }
        }
        if (comboCount > 1) {
          const comboBonus = Math.floor(reward * (comboCount * balanceConfig.comboMultiplier));
          reward += comboBonus;
          showComboText(comboCount, comboBonus, block);
          playSound('comboSound');
        }
        coins += reward;
        gameMetrics.blocksDestroyed++;
        updateCoins();
        playSound('breakSound');
        showRewardText(reward, block);
        createExplosion(block);
        if (gameArea.contains(block)) {
          gameArea.removeChild(block);
        }
        currentBlock = null;
        currentBlockHealth = 0;
        setTimeout(() => {
          if (gameActive) {
            createMovingBlock();
          }
        }, 500);
      }

      function getBlockSize() {
        const baseSize = isMobile ? 80 : 60;
        const locationIndex = Object.keys(locationRequirements).indexOf(currentLocation);
        if (locationIndex < 3) {
          return baseSize * 1.2;
        }
        return baseSize * (1 + locationIndex * 0.15);
      }

      function createMovingBlock() {
        if (currentBlock && gameArea.contains(currentBlock)) {
          gameArea.removeChild(currentBlock);
        }
        const blockHealth = calculateBlockHealth();
        currentBlockHealth = blockHealth;
        const block = document.createElement("div");
        block.className = "moving-block";
        const size = getBlockSize();
        block.style.width = size + "px";
        block.style.height = size + "px";
        block.style.bottom = "0px";
        block.dataset.maxHealth = blockHealth;
        const theme = locations[currentLocation];
        const colorIndex = Math.floor(Math.random() * theme.blockColors.length);
        let isRare = false;
        let rareType = null;
        const potentialRareType = getRareBlockType();
        if (potentialRareType) {
          isRare = true;
          rareType = potentialRareType;
          const rareBlock = rareBlocks[rareType];
          block.classList.add(rareBlock.className);
          currentBlockHealth = Math.floor(currentBlockHealth * rareBlock.healthMultiplier);
          block.innerHTML = `üåü<div style="font-size: 0.35em; margin-top: 1px; line-height: 1.1;">${rareBlock.name}</div>`;
          announceRareBlock(rareBlock.name);
        } else {
          block.style.background = `linear-gradient(135deg, ${theme.blockColors[colorIndex]}, ${theme.blockColors[(colorIndex + 1) % theme.blockColors.length]})`;
          block.style.boxShadow = `0 0 15px ${theme.blockColors[colorIndex]}`;
          block.style.border = `2px solid ${theme.borderColor}`;
          block.textContent = blockHealth;
        }
        const expectedClicks = getExpectedClicks(currentBlockHealth, clickPower);
        block.addEventListener('click', () => hitBlock(block, clickPower));
        block.addEventListener('touchstart', (e) => {
          e.preventDefault();
          hitBlock(block, clickPower);
        }, { passive: false });
        gameArea.appendChild(block);
        currentBlock = block;
        animateBlock(block);
      }

      function animateBlock(block) {
        if (!gameActive) return;
        const speed = getCurrentSpeed();
        let position = parseInt(block.style.bottom) || 0;
        function move() {
          if (!gameActive || currentBlock !== block) return;
          position += speed / 30;
          block.style.bottom = position + "px";
          if (position > window.innerHeight) {
            gameOver();
            return;
          }
          requestAnimationFrame(move);
        }
        move();
      }

      function gameOver(customMessage = null) {
        gameActive = false;
        helperActive = false;
        if (helperInterval) clearInterval(helperInterval);
        if (helperElement && helperElement.parentNode) {
          document.body.removeChild(helperElement);
          helperElement = null;
        }
        const sessionTime = Date.now() - gameMetrics.startTime;
        console.log('üéÆ [–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä] –°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞:', {
          session: gameMetrics.sessions,
          duration_sec: Math.round(sessionTime / 1000),
          total_damage: totalDamageDealt,
          current_location: currentLocation,
          total_coins: coins,
          blocks_destroyed: gameMetrics.blocksDestroyed,
          upgrades_bought: gameMetrics.upgradesBought,
          total_clicks: gameMetrics.totalClicks
        });
        localStorage.setItem('gameSessions', gameMetrics.sessions.toString());
        if (currentBlock && gameArea.contains(currentBlock)) {
          gameArea.removeChild(currentBlock);
          currentBlock = null;
        }
        if (finalScoreDisplay) {
          finalScoreDisplay.textContent = `–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: ${Math.floor(totalDamageDealt).toLocaleString()}`;
        }
        if (gameOverScreen) {
          gameOverScreen.style.display = "flex";
        }
        if (customMessage) {
          const h2 = gameOverScreen.querySelector('h2');
          if (h2) h2.textContent = customMessage;
        }
      }

      function shareResult() {
        const shareText = `üéÆ –Ø –Ω–∞–Ω–µ—Å ${Math.floor(totalDamageDealt).toLocaleString()} —É—Ä–æ–Ω–∞ –∏ —Å–æ–±—Ä–∞–ª ${Math.floor(coins)} –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ! üåå
–°–º–æ–∂–µ—à—å –ø–æ–±–∏—Ç—å –º–æ–π —Ä–µ–∫–æ—Ä–¥?`;
        if (navigator.share) {
          navigator.share({
            title: '–ú–æ–π —Ä–µ–∫–æ—Ä–¥ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ!',
            text: shareText
          }).then(() => {
            coins += 50;
            updateCoins();
            showTooltip('+50 –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –∑–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ!');
            setTimeout(hideTooltip, 2000);
            saveGame();
          });
        } else {
          navigator.clipboard.writeText(shareText).then(() => {
            alert('–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω! –ü–æ–¥–µ–ª–∏—Å—å —Å –¥—Ä—É–∑—å—è–º–∏!');
            coins += 50;
            updateCoins();
            saveGame();
          });
        }
      }

      function showTooltip(text) {
        if (tooltip) {
          tooltip.innerHTML = text;
          tooltip.style.opacity = "1";
        }
      }

      function hideTooltip() {
        if (tooltip) tooltip.style.opacity = "0";
      }

      function startGame(reset = true) {
        if (reset) {
          coins = 0;
          totalDamageDealt = 0;
          currentLocation = 'mercury';
          clickPower = 1;
          clickUpgradeLevel = 0;
          helperUpgradeLevel = 0;
          helperDamageBonus = 0.3;
          critChance = 0.01;
          critMultiplier = 2.0;
          helperActive = false;
          helperTimeLeft = 0;
          localStorage.removeItem('cosmicBlocksSave');
        }
        if (helperInterval) {
          clearInterval(helperInterval);
          helperInterval = null;
        }
        if (helperElement && helperElement.parentNode) {
          document.body.removeChild(helperElement);
          helperElement = null;
        }
        gameArea.innerHTML = "";
        if (welcomeScreen) {
          welcomeScreen.style.display = "none";
        }
        if (saveScreen) {
          saveScreen.style.display = "none";
        }
        if (developmentScreen) {
          developmentScreen.style.display = "none";
        }
        if (gameOverScreen) {
          gameOverScreen.style.display = "none";
        }
        gameActive = true;
        comboCount = 0;
        lastDestroyTime = 0;
        gameMetrics.startTime = Date.now();
        gameMetrics.blocksDestroyed = 0;
        gameMetrics.upgradesBought = 0;
        gameMetrics.totalClicks = 0;
        updateCoins();
        updateProgressBar();
        updateUpgradeButtons();
        setLocation(currentLocation);
        setTimeout(() => createMovingBlock(), 500);
      }

      function continueGame() {
        if (loadGame()) {
          clickPower = calculateClickPower();
          startGame(false);
        } else {
          showTooltip("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã!");
          setTimeout(hideTooltip, 2000);
        }
      }

      function showSaveScreen() {
        if (saveScreen) {
          saveScreen.style.display = "flex";
        }
      }

      function restartGame() {
        startGame(true);
      }

      // === –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ===
      if (startBtn) {
        startBtn.addEventListener('click', function() {
          try {
            showSaveScreen();
          } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
            showTooltip("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            setTimeout(hideTooltip, 3000);
          }
        });
        startBtn.addEventListener('touchstart', function(e) {
          e.preventDefault();
          try {
            showSaveScreen();
          } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
            showTooltip("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            setTimeout(hideTooltip, 3000);
          }
        }, { passive: false });
      }

      if (continueBtn) {
        continueBtn.addEventListener('click', function() {
          try {
            const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
            if (hasSave) {
              showSaveScreen();
            } else {
              showTooltip("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã!");
              setTimeout(hideTooltip, 2000);
            }
          } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
            showTooltip("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            setTimeout(hideTooltip, 3000);
          }
        });
        continueBtn.addEventListener('touchstart', function(e) {
          e.preventDefault();
          try {
            const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
            if (hasSave) {
              showSaveScreen();
            } else {
              showTooltip("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã!");
              setTimeout(hideTooltip, 2000);
            }
          } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
            showTooltip("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            setTimeout(hideTooltip, 3000);
          }
        }, { passive: false });
      }

      if (loadSaveBtn) {
        loadSaveBtn.addEventListener('click', continueGame);
        loadSaveBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          continueGame();
        }, { passive: false });
      }

      if (newGameBtn) {
        newGameBtn.addEventListener('click', () => startGame(true));
        newGameBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          startGame(true);
        }, { passive: false });
      }

      if (cancelSaveBtn) {
        cancelSaveBtn.addEventListener('click', () => {
          if (saveScreen) saveScreen.style.display = "none";
        });
        cancelSaveBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (saveScreen) saveScreen.style.display = "none";
        }, { passive: false });
      }

      if (restartFromDevBtn) {
        restartFromDevBtn.addEventListener('click', restartGame);
        restartFromDevBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          restartGame();
        }, { passive: false });
      }

      function addMobileButtonHandlers(button, handler) {
        if (button) {
          button.addEventListener('click', handler);
          button.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handler();
          }, { passive: false });
        }
      }

      addMobileButtonHandlers(upgradeClickBtn, buyClickPower);
      addMobileButtonHandlers(upgradeHelperBtn, buyHelper);
      addMobileButtonHandlers(upgradeCritChanceBtn, buyCritChance);
      addMobileButtonHandlers(upgradeCritMultBtn, buyCritMultiplier);
      addMobileButtonHandlers(upgradeHelperDmgBtn, buyHelperDamage);

      if (upgradeClickBtn) {
        upgradeClickBtn.addEventListener('mouseenter', () => showTooltip('–°–∏–ª–∞ —É–¥–∞—Ä–∞<br>–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π —Ä–æ—Å—Ç —É—Ä–æ–Ω–∞'));
        upgradeClickBtn.addEventListener('mouseleave', hideTooltip);
      }
      if (upgradeHelperBtn) {
        upgradeHelperBtn.addEventListener('mouseenter', () => showTooltip('Bobo<br>–ê–≤—Ç–æ-–∞—Ç–∞–∫–∞ –Ω–∞ 1 –º–∏–Ω—É—Ç—É<br>+30% —É—Ä–æ–Ω–∞'));
        upgradeHelperBtn.addEventListener('mouseleave', hideTooltip);
      }
      if (upgradeCritChanceBtn) {
        upgradeCritChanceBtn.addEventListener('mouseenter', () => showTooltip('–®–∞–Ω—Å –∫—Ä–∏—Ç–∞<br>+1% —à–∞–Ω—Å –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞'));
        upgradeCritChanceBtn.addEventListener('mouseleave', hideTooltip);
      }
      if (upgradeCritMultBtn) {
        upgradeCritMultBtn.addEventListener('mouseenter', () => showTooltip('–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞<br>+0.2x –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞'));
        upgradeCritMultBtn.addEventListener('mouseleave', hideTooltip);
      }
      if (upgradeHelperDmgBtn) {
        upgradeHelperDmgBtn.addEventListener('mouseenter', () => showTooltip('–£—Ä–æ–Ω Bobo<br>+20% —É—Ä–æ–Ω–∞ –∑–∞ –∞–ø–≥—Ä–µ–π–¥'));
        upgradeHelperDmgBtn.addEventListener('mouseleave', hideTooltip);
      }

      addMobileButtonHandlers(restartBtn, restartGame);
      addMobileButtonHandlers(shareBtn, shareResult);
      addMobileButtonHandlers(dailyRewardBtn, checkDailyReward);

      if (saveBtn) {
        saveBtn.addEventListener('click', saveGame);
        saveBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          saveGame();
        }, { passive: false });
      }

      // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
      updateContinueButton();
      updateCoins();
      updateProgressBar();
      setLocation(currentLocation);
      
      window.addEventListener('resize', function() {
        if (helperElement) {
          moveHelperToRandomPosition();
        }
      });

      document.addEventListener('touchstart', function(e) {
        if (e.touches.length > 1) {
          e.preventDefault();
        }
      }, { passive: false });
      document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
      }, { passive: false });
      document.addEventListener('gesturechange', function(e) {
        e.preventDefault();
      }, { passive: false });
      document.addEventListener('gestureend', function(e) {
        e.preventDefault();
      }, { passive: false });
    });
  </script>
</body>
</html>